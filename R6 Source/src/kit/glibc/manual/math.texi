@c We need some definitions here.
@ifhtml
@set mult ·
@end ifhtml
@iftex
@set mult @cdot
@end iftex
@ifclear mult
@set mult x
@end ifclear
@macro mul
@value{mult}
@end macro
@iftex
@set infty @infty
@end iftex
@ifclear infty
@set infty oo
@end ifclear
@macro infinity
@value{infty}
@end macro

@node Mathematics, Arithmetic, Low-Level Terminal Interface, Top
@chapter Mathematics

This chapter contains information about functions for performing
mathematical computations, such as trigonometric functions.  Most of
these functions have prototypes declared in the header file
@file{math.h}.
@pindex math.h

For all functions which take a single floating-point argument and for
several other functions as well there are three different functions
available for the type @code{double}, @code{float}, and @code{long
double}.  The @code{double} versions of the functions are mostly defined
even in the @w{ISO C 89} standard.  The @code{float} and @code{long
double} variants are introduced in the numeric extensions for the C
language which are part of the @w{ISO C 9X} standard.

Which of the three versions of the function should be used depends on
the situation.  For most functions and implementation it is true that
speed and precision do not go together.  I.e., the @code{float} versions
are normally faster than the @code{double} and @code{long double}
versions.  On the other hand the @code{long double} version has the
highest precision.  One should always think about the actual needs and
in case of double using @code{double} is a good compromise.


@menu
* Domain and Range Errors::      Detecting overflow conditions and the like.
* Exceptions in Math Functions:: Signalling exception in math functions.
* Mathematical Constants::       Precise numeric values for often used
                                  constant.
* FP Comparison Functions::      Special functions to compare floating-point
                                  numbers.
* FP Function Optimizations::    Fast code or small code.
* Trig Functions::               Sine, cosine, and tangent.
* Inverse Trig Functions::       Arc sine, arc cosine, and arc tangent.
* Exponents and Logarithms::     Also includes square root.
* Hyperbolic Functions::         Hyperbolic sine and friends.
* Pseudo-Random Numbers::        Functions for generating pseudo-random
				  numbers.
@end menu

@node Domain and Range Errors
@section Domain and Range Errors

@cindex domain error
Many of the functions listed in this chapter are defined mathematically
over a domain that is only a subset of real numbers.  For example, the
@code{acos} function is defined over the domain between @code{@minus{}1} and
@code{1}.  If you pass an argument to one of these functions that is
outside the domain over which it is defined, the function sets
@code{errno} to @code{EDOM} to indicate a @dfn{domain error}.  On
machines that support @w{IEEE 754} floating point, functions reporting
error @code{EDOM} also return a NaN.

Some of these functions are defined mathematically to result in a
complex value over parts of their domains.  The most familiar example of
this is taking the square root of a negative number.  The functions in
this chapter take only real arguments and return only real values;
therefore, if the value ought to be nonreal, this is treated as a domain
error.

@cindex range error
A related problem is that the mathematical result of a function may not
be representable as a floating point number.  If magnitude of the
correct result is too large to be represented, the function sets
@code{errno} to @code{ERANGE} to indicate a @dfn{range error}, and
returns a particular very large value (named by the macro
@code{HUGE_VAL}) or its negation (@code{@minus{}HUGE_VAL}).

If the magnitude of the result is too small, a value of zero is returned
instead.  In this case, @code{errno} might or might not be
set to @code{ERANGE}.

The only completely reliable way to check for domain and range errors is
to set @code{errno} to @code{0} before you call the mathematical function
and test @code{errno} afterward.  As a consequence of this use of
@code{errno}, use of the mathematical functions is not reentrant if you
check for errors.

@c ### This is no longer true.  --drepper
@c None of the mathematical functions ever generates signals as a result of
@c domain or range errors.  In particular, this means that you won't see
@c @code{SIGFPE} signals generated within these functions.  (@xref{Signal
@c Handling}, for more information about signals.)

@comment math.h
@comment ISO
@deftypevr Macro double HUGE_VAL
An expression representing a particular very large number.  On machines
that use @w{IEEE 754}/@w{IEEE 854} floating point format, the value is
``infinity''.  On other machines, it's typically the largest positive
number that can be represented.

The value of this macro is used as the return value from various
mathematical @code{double} returning functions in overflow situations.
@end deftypevr

@comment math.h
@comment ISO
@deftypevr Macro float HUGE_VALF
This macro is similar to the @code{HUGE_VAL} macro except that it is
used by functions returning @code{float} values.

This macro is introduced in @w{ISO C 9X}.
@end deftypevr

@comment math.h
@comment ISO
@deftypevr Macro {long double} HUGE_VALL
This macro is similar to the @code{HUGE_VAL} macro except that it is
used by functions returning @code{long double} values.  The value is
only different from @code{HUGE_VAL} if the architecture really supports
@code{long double} values.

This macro is introduced in @w{ISO C 9X}.
@end deftypevr


A special case is the @code{ilogb} function @pxref{Exponents and
Logarithms}.  Since the return value is an integer value, one cannot
compare with @code{HUGE_VAL} etc.  Therefore two further values are
defined.

@comment math.h
@comment ISO
@deftypevr Macro int FP_ILOGB0
This value is returned by @code{ilogb} if the argument is @code{0}.  The
numeric value is either @code{INT_MIN} or @code{-INT_MAX}.

This macro is introduced in @w{ISO C 9X}.
@end deftypevr

@comment math.h
@comment ISO
@deftypevr Macro int FP_ILOGBNAN
This value is returned by @code{ilogb} if the argument is @code{NaN}.  The
numeric value is either @code{INT_MIN} or @code{INT_MAX}.

This macro is introduced in @w{ISO C 9X}.
@end deftypevr


For more information about floating-point representations and limits,
see @ref{Floating Point Parameters}.  In particular, the macro
@code{DBL_MAX} might be more appropriate than @code{HUGE_VAL} for many
uses other than testing for an error in a mathematical function.


@node Exceptions in Math Functions
@section Exceptions in Math Functions
@cindex exception
@cindex signal

Due to the restrictions in the size of the floating-point number
representation or the limitation of the input range of certain functions
some of the mathematical operations and functions have to signal
exceptional situations.  The @w{IEEE 754} standard specifies which
exceptions have to be supported and how they can be handled.

@w{IEEE 754} specifies two actions for floating-point exception: taking
a trap or continuing without doing so.  If the trap is taken a
(possibly) user defined trap handler is called and this function can
correct the argument or react somehow else on the call.  If the trap
handler returns, its return value is taken as the result of the
operation.

If no trap handler is called each of the known exceptions has a default
action.  This consists of setting a corresponding bit in the
floating-point status word to indicate which kind of exception was
raised and to return a default value, which depends on the exception
(see the table below).

@noindent
The exceptions defined in @w{IEEE 754} are:

@table @samp
@item Invalid Operation
This exception is raised if the given operands are invalid for the
operation to be performed.  Examples are
(see @w{IEEE 754}, @w{section 7}):
@enumerate
@item
Any operation on a signalling NaN.
@item
Addition or subtraction; magnitude subtraction of infinities such as
@math{(+@infinity{}) + (-@infinity{})}.
@item
Multiplication:
@math{0 @mul{} @infinity{}}.

@item
Division: @math{0/0} or @math{@infinity{}/@infinity{}}.

@item
Remainder: @math{x} REM @math{y}, where @math{y} is zero or @math{x} is
infinite.
@item
Square root if the operand is less then zero.
@item
Conversion of an internal floating-point number to an integer or to a
decimal string when overflow, infinity, or NaN precludes a faithful
representation in that format and this cannot otherwise be signaled.
@item
Conversion of an unrecognizable input string.
@item
Comparison via predicates involving @math{<} or @math{>}, without
@code{?}, when the operands are @dfn{unordered}.  (@math{?>} means the
unordered greater relation, @xref{FP Comparison Functions}).
@end enumerate

If the exception does not cause a trap handler to be called the result
of the operation is taken as a quiet NaN.

@item Division by Zero
This exception is raised if the divisor is zero and the dividend is a
finite nonzero number.  If no trap occurs the result is either
@math{+@infinity{}} or @math{-@infinity{}}, depending on the
signs of the operands.

@item Overflow
This exception is signalled whenever the result cannot be represented
as a finite value in the precision format of the destination.  If no trap
occurs the result depends on the sign of the intermediate result and the
current rounding mode (@w{IEEE 754}, @w{section 7.3}):
@enumerate
@item
Round to nearest carries all overflows to @math{@infinity{}}
with the sign of the intermediate result.
@item
Round toward @math{0} carries all overflows to the precision's largest
finite number with the sign of the intermediate result.
@item
Round toward @math{-@infinity{}} carries positive overflows to the
precision's largest finite number and carries negative overflows to
@math{-@infinity{}}.

@item
Round toward @math{@infinity{}} carries negative overflows to the
precision's most negative finite number and carries positive overflows
to @math{@infinity{}}.
@end enumerate

@item Underflow
The underflow exception is created when an intermediate result is too
small for the operation or if the operations result rounded to the
destination precision causes a loss of accuracy by approximating the
result by denormalized numbers.

When no trap is installed for the underflow exception, underflow shall
be signaled (via the underflow flag) only when both tininess and loss of
accuracy have been detected.  If no trap handler is installed the
operation continues with an inprecise small value or zero if the
destination precision cannot hold the small exact result.

@item Inexact
This exception is signalled if the rounded result is not exact (such as
computing the square root of two) or the result overflows without an
overflow trap.
@end table

To control whether an exception causes a trap to occur all @w{IEEE 754}
conformant floating-point implementations (either hardware or software)
have a control word.  By setting specific bits for each exception in
this control word the programmer can decide whether a trap is wanted or
not.

@w{ISO C 9X} introduces a set of function which can be used to control
exceptions.  There are functions to manipulate the control word, to
query the status word or to save and restore the whole state of the
floating-point unit.  There are also functions to control the rounding
mode used.

@menu
* Status bit operations::       Manipulate the FP status word.
* FPU environment::             Controlling the status of the FPU.
* Rounding Modes::              Controlling the rounding mode.
@end menu

@node Status bit operations
@subsection Controlling the FPU status word

To control the five types of exceptions defined in @w{IEEE 754} some
functions are defined which abstract the interface to the FPU.  The
actual implementation can be very different, depending on the underlying
hardware or software.

To address the single exception the @file{fenv.h} headers defines a
number of macros:

@vtable @code
@comment fenv.h
@comment ISO
@item FE_INEXACT
Represents the inexact exception iff the FPU supports this exception.
@comment fenv.h
@comment ISO
@item FE_DIVBYZERO
Represents the divide by zero exception iff the FPU supports this exception.
@comment fenv.h
@comment ISO
@item FE_UNDERFLOW
Represents the underflow exception iff the FPU supports this exception.
@comment fenv.h
@comment ISO
@item FE_OVERFLOW
Represents the overflow exception iff the FPU supports this exception.
@comment fenv.h
@comment ISO
@item FE_INVALID
Represents the invalid exception iff the FPU supports this exception.
@end vtable

The macro @code{FE_ALL_EXCEPT} is the bitwise OR of all exception macros
which are supported by the FP implementation.

Each of the supported exception flags can either be set or unset.  The
@w{ISO C 9X} standard defines functions to set, unset and test the
status of the flags.

@comment fenv.h
@comment ISO
@deftypefun void feclearexcept (int @var{excepts})
This function clears all of the supported exception flags denoted by
@var{excepts} in the status word.
@end deftypefun

To safe the current status of the flags in the status word @file{fenv.h}
defines the type @code{fexcept_t} which can hold all the information.
The following function can be used to retrieve the current setting.

@comment fenv.h
@comment ISO
@deftypefun void fegetexceptflag (fexcept_t *@var{flagp}, int @var{excepts})
Store in the variable pointed to by @var{flagp} an
implementation-defined value representing the current setting of the
exception flags indicated by the parameter @var{excepts}.
@end deftypefun

@noindent
To restore the previously saved values one can use this function:

@comment fenv.h
@comment ISO
@deftypefun void fesetexceptflag (const fexcept_t *@var{flagp}, int @var{excepts})
Restore from the variable pointed to by @var{flagp} the setting of the
flags for the exceptions denoted by the value of the parameter
@var{excepts}.
@end deftypefun

The last function allows to query the current status of the flags.  The
flags can be set either explicitely (using @code{fesetexceptflag} or
@code{feclearexcept}) or by a floating-point operation which happened
before.  Since the flags are accumulative, the flags must be explicitely
reset using @code{feclearexcept} if one wants to test for a certain
exceptions raised by a specific piece of code.

@comment fenv.h
@comment ISO
@deftypefun int fetestexcept (int @var{excepts})
Test whether a subset of the flags indicated by the parameter
@var{except} is currently set.  If yes, a nonzero value is returned
which specifies which exceptions are set.  Otherwise the result is zero.
@end deftypefun

@noindent
Code which uses the @code{fetestexcept} function could look like this:

@smallexample
@{
  double f;
  int raised;
  feclearexcept (FE_ALL_EXCEPT);
  f = compute ();
  raised = fetestexcept (FE_OVERFLOW | FE_INVALID);
  if (raised & FE_OVERFLOW) @{ /* ... */ @}
  if (raised & FE_INVALID) @{ /* ... */ @}
  /* ... */
@}
@end smallexample

Please note that the return value of @code{fetestexcept} is @code{int}
but this does not mean that the @code{fexcept_t} type is generally
representable as an integer.  These are completely independent types.


@node FPU environment
@subsection Controlling the Floating-Point environment

It is sometimes necessary so save the complete status of the
floating-point unit for a certain time to perform some completely
different actions.  Beside the status of the exception flags, the
control word for the exceptions and the rounding mode can be saved.

The file @file{fenv.h} defines the type @code{fenv_t}.  The layout of a
variable of this type is implementation defined but the variable is able
to contain the complete status information.  To fill a variable of this
type one can use this function:

@comment fenv.h
@comment ISO
@deftypefun void fegetenv (fenv_t *@var{envp})
Store the current floating-point environment in the object pointed to by
@var{envp}.
@end deftypefun

@noindent
Another possibility which is useful in several situations is

@comment fenv.h
@comment ISO
@deftypefun int feholdexcept (fenv_t *@var{envp})
Store the current floating-point environment in the object pointed to by
@var{envp}.  Afterwards, all exception flags are cleared and if
available a mode is installed which continues on all exceptions and does
not cause a trap to occur.  In this case a nonzero value is returned.

If the floating-point implementation does not support such a non-stop
mode, the return value is zero.
@end deftypefun

The functions which allow a state of the floating-point unit to be
restored can take two kinds of arguments:

@itemize @bullet
@item
Pointers to @code{fenv_t} objects which were initialized previously by a
call to @code{fegetenv} or @code{feholdexcept}.
@item
@vindex FE_DFL_ENV
The special macro @code{FE_DFL_ENV} which represents the floating-point
environment as it was available at program start.
@item
Implementation defined macros with names starting with @code{FE_}.

@vindex FE_NOMASK_ENV
If possible, the GNU C Library defines a macro @code{FE_NOMASK_ENV}
which represents an environment where no exceptions are masked, so every
exception raised causes a trap to occur.  You can test for this macro
using @code{#ifdef}.

Some platforms might define other predefined environments.
@end itemize

@noindent
To set any of the environments there are two functions defined.

@deftypefun void fesetenv (const fenv_t *@var{envp})
Establish the floating-point environment described in the object pointed
to by @var{envp}.  Even if one or more exceptions flags in the restored
environment are set no exception is raised.
@end deftypefun

In some situations the previous status of the exception flags must not
simply be discarded and so this function is useful:

@deftypefun void feupdateenv (const fenv_t *@var{envp})
The current status of the floating-point unit is preserved in some
automatic storage before the environment described by the object pointed
to by @var{envp} is installed.  Once this is finished all exceptions set
in the original environment which is saved in the automatic storage, is
raised.
@end deftypefun

This function can be used to execute a part of the program with an
environment which masks all exceptions and before switching back remove
unwanted exception and raise the remaining exceptions.


@node Rounding Modes
@subsection Rounding modes of the Floating-Point Unit

@w{IEEE 754} defines four different rounding modes.  If the rounding
mode is supported by the floating-point implementation the corresponding
of the following macros is defined:

@table @code
@comment fenv.h
@comment ISO
@vindex FE_TONEAREST
@item FE_TONEAREST
Round to nearest.  This is the default mode and should always be used
except when a different mode is explicitely required.  Only rounding to
nearest guarantees numeric stability of the computations.

@comment fenv.h
@comment ISO
@vindex FE_UPWARD
@item FE_UPWARD
Round toward @math{+@infinity{}}.

@comment fenv.h
@comment ISO
@vindex FE_DOWNWARD
@item FE_DOWNWARD
Round toward @math{-@infinity{}}.

@comment fenv.h
@comment ISO
@vindex FE_TOWARDZERO
@item FE_TOWARDZERO
Round toward zero.
@end table

At any time one of the above four rounding modes is selected.  To get
information about the currently selected mode one can use this function:

@comment fenv.h
@comment ISO
@deftypefun int fegetround (void)
Return the currently selected rounding mode, represented by one of the
values of the defined rounding mode macros.
@end deftypefun

@noindent
To set a specific rounding mode the next function can be used.

@comment fenv.h
@comment ISO
@deftypefun int fesetround (int @var{round})
Change the currently selected rounding mode to the mode described by the
parameter @var{round}.  If @var{round} does not correspond to one of the
supported rounding modes nothing is changed.

The function returns a nonzero value iff the requested rounding mode can
be established.  Otherwise zero is returned.
@end deftypefun

Changing the rounding mode might be necessary for various reasons.  But
changing the mode only to round a given number normally is no good idea.
The standard defines a set of functions which can be used to round an
argument according to some rules and for all of the rounding modes there
is a corresponding function.

If a large set of number has to be rounded it might be good to change
the rounding mode and to not use the function the library provides.  So
the perhaps necessary switching of the rounding mode in the library
function can be avoided.  But since not all rounding modes are
guaranteed to exist on any platform this possible implementation cannot
be portably used.  A default method has to be implemented as well.


@node Mathematical Constants
@section Predefined Mathematical Constants
@cindex constants
@cindex mathematical constants

The header @file{math.h} defines a series of mathematical constants if
@code{_BSD_SOURCE} or a more general feature select macro is defined
before including this file.  All values are defined as preprocessor
macros starting with @code{M_}.  The collection includes:

@vtable @code
@item M_E
The value is that of the base of the natural logarithm.
@item M_LOG2E
The value is computed as the logarithm to base @code{2} of @code{M_E}.
@item M_LOG10E
The value is computed as the logarithm to base @code{10} of @code{M_E}.
@item M_LN2
The value is computed as the natural logarithm of @code{2}.
@item M_LN10
The value is computed as the natural logarithm of @code{10}.
@item M_PI
The value is those of the number pi.
@item M_PI_2
The value is those of the number pi divided by two.
@item M_PI_4
The value is those of the number pi divided by four.
@item M_1_PI
The value is the reziprocal of the value of the number pi.
@item M_2_PI
The value is two times the reziprocal of the value of the number pi.
@item M_2_SQRTPI
The value is two times the reziprocal of the square root of the number pi.
@item M_SQRT2
The value is the square root of the value of the number pi.
@item M_SQRT1_2
The value is the reziprocal of the square root of the value of the number pi.
@end vtable

All values are defined as @code{long double} values unless the compiler
does not support this type or @code{__STDC__} is not defined (both is
unlikely).  Historically the numbers were @code{double} values and some
old code still relies on this so you might want to add explicit casts if
the extra precision of the @code{long double} value is not needed.  One
critical case are functions with a variable number of arguments, such as
@code{printf}.

@vindex PI
@emph{Note:} Some programs use a constant named @code{PI} which has the
same value as @code{M_PI}.  This probably derives from Stroustroup's
book about his C++ programming language where this value is used in
examples (and perhaps some AT&T headers contain this value).  But due to
possible name space problems (@code{PI} is a quite frequently used name)
this value is not added to @file{math.h}.  Every program should use
@code{M_PI} instead or add on the compiler command line
@code{-DPI=M_PI}.


@node FP Comparison Functions
@section Floating-Point Comparison Functions
@cindex unordered comparison

The @w{IEEE 754} standards defines a set of functions which allows to
compare even those numbers which normally would cause an exception to be
raised since they are unordered.  E.g., the expression

@smallexample
int v = a < 1.0;
@end smallexample

@noindent
would raise an exception if @var{a} would be a NaN.  Functions to
compare unordered numbers are part of the FORTRAN language for a long
time and the extensions in @w{ISO C 9X} finally introduce them as well
for the C programming language.

All of the operations are implemented as macros which allow their
arguments to be of either @code{float}, @code{double}, or @code{long
double} type.

@comment math.h
@comment ISO
@deftypefn {Macro} int isgreater (@emph{real-floating} @var{x}, @emph{real-floating} @var{y})
This macro determines whether the argument @var{x} is greater than
@var{y}.  This is equivalent to @code{(@var{x}) > (@var{y})} but no
exception is raised if @var{x} or @var{y} are unordered.
@end deftypefn

@comment math.h
@comment ISO
@deftypefn {Macro} int isgreaterequal (@emph{real-floating} @var{x}, @emph{real-floating} @var{y})
This macro determines whether the argument @var{x} is greater than or
equal to @var{y}.  This is equivalent to @code{(@var{x}) >= (@var{y})} but no
exception is raised if @var{x} or @var{y} are unordered.
@end deftypefn

@comment math.h
@comment ISO
@deftypefn {Macro} int isless (@emph{real-floating} @var{x}, @emph{real-floating} @var{y})
This macro determines whether the argument @var{x} is less than @var{y}.
This is equivalent @code{(@var{x}) < (@var{y})} but no exception is raised if
@var{x} or @var{y} are unordered.
@end deftypefn

@comment math.h
@comment ISO
@deftypefn {Macro} int islessequal (@emph{real-floating} @var{x}, @emph{real-floating} @var{y})
This macro determines whether the argument @var{x} is less than or equal
to @var{y}.  This is equivalent to @code{(@var{x}) <= (@var{y})} but no
exception is raised if @var{x} or @var{y} are unordered.
@end deftypefn

@comment math.h
@comment ISO
@deftypefn {Macro} int islessgreater (@emph{real-floating} @var{x}, @emph{real-floating} @var{y})
This macro determines whether the argument @var{x} is less or greater
than @var{y}.  This is equivalent to @code{(@var{x}) < (@var{y}) ||
(@var{x}) > (@var{y})} (except that @var{x} and @var{y} are only
evaluated once) but no exception is raised if @var{x} or @var{y} are
unordered.
@end deftypefn

@comment math.h
@comment ISO
@deftypefn {Macro} int isunordered (@emph{real-floating} @var{x}, @emph{real-floating} @var{y})
This macro determines whether its arguments are unordered.
@end deftypefn

All the macros are defined in a way to ensure that both arguments are
evaluated exactly once and so they can be used exactly like the builtin
operators.

On several platform these macros are mapped to efficient instructions
the processor understands.  But on machines missing these functions, the
macros above might be rather slow.  So it is best to use the builtin
operators unless it is necessary to use unordered comparisons.

@strong{Note:} There are no macros @code{isequal} or @code{isunequal}.
These macros are not necessary since the @w{IEEE 754} standard requires
that the comparison for equality and unequality do @emph{not} throw an
exception if one of the arguments is an unordered value.


@node FP Function Optimizations
@section Is Fast Code or Small Code preferred?
@cindex Optimization

If an application uses many floating point function it is often the case
that the costs for the function calls itselfs are not neglectable.
Modern processor implementation often can execute the operation itself
very fast but the call means a disturbance of the control flow.

For this reason the GNU C Library provides optimizations for many of the
frequently used math functions.  When the GNU CC is used and the user
activates the optimizer several new inline functions and macros get
defined.  These new functions and macros have the same names as the
library function and so get used instead of the later.  In case of
inline functions the compiler will decide whether it is reasonable to
use the inline function and this decision is usually correct.

For the generated code this means that no calls to the library functions
are necessary.  This increases the speed significantly.  But the
drawback is that the code size increases and this increase is not always
neglectable.

In cases where the inline functions and macros are not wanted the symbol
@code{__NO_MATH_INLINES} should be defined before any system header is
included.  This will make sure only library functions are used.  Of
course it can be determined for each single file in the project whether
giving this option is preferred or not.


@node Trig Functions
@section Trigonometric Functions
@cindex trigonometric functions

These are the familiar @code{sin}, @code{cos}, and @code{tan} functions.
The arguments to all of these functions are in units of radians; recall
that pi radians equals 180 degrees.

@cindex pi (trigonometric constant)
The math library does define a symbolic constant for pi in @file{math.h}
(@pxref{Mathematical Constants}) when BSD compliance is required
(@pxref{Feature Test Macros}).  In case it is not possible to use this
predefined macro one easily can define it:

@smallexample
#define M_PI 3.14159265358979323846264338327
@end smallexample

@noindent
You can also compute the value of pi with the expression @code{acos
(-1.0)}.


@comment math.h
@comment ISO
@deftypefun double sin (double @var{x})
@deftypefunx float sinf (float @var{x})
@deftypefunx {long double} sinl (long double @var{x})
These functions return the sine of @var{x}, where @var{x} is given in
radians.  The return value is in the range @code{-1} to @code{1}.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double cos (double @var{x})
@deftypefunx float cosf (float @var{x})
@deftypefunx {long double} cosl (long double @var{x})
These functions return the cosine of @var{x}, where @var{x} is given in
radians.  The return value is in the range @code{-1} to @code{1}.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double tan (double @var{x})
@deftypefunx float tanf (float @var{x})
@deftypefunx {long double} tanl (long double @var{x})
These functions return the tangent of @var{x}, where @var{x} is given in
radians.

The following @code{errno} error conditions are defined for this function:

@table @code
@item ERANGE
Mathematically, the tangent function has singularities at odd multiples
of pi/2.  If the argument @var{x} is too close to one of these
singularities, @code{tan} sets @code{errno} to @code{ERANGE} and returns
either positive or negative @code{HUGE_VAL}.
@end table
@end deftypefun

In many applications where @code{sin} and @code{cos} are used, the value
for the same argument of both of these functions is used at the same
time.  Since the algorithm to compute these values is very similar for
both functions there is an additional function which computes both values
at the same time.

@comment math.h
@comment GNU
@deftypefun void sincos (double @var{x}, double *@var{sinx}, double *@var{cosx})
@deftypefunx void sincosf (float @var{x}, float *@var{sinx}, float *@var{cosx})
@deftypefunx void sincosl (long double @var{x}, long double *@var{sinx}, long double *@var{cosx})
These functions return the sine of @var{x} in @code{*@var{sinx}} and the
cosine of @var{x} in @code{*@var{cos}}, where @var{x} is given in
radians.  Both values, @code{*@var{sinx}} and @code{*@var{cosx}}, are in
the range of @code{-1} to @code{1}.

This function is a GNU extension.  It should be used whenever both sine
and cosine are needed but in portable applications there should be a
fallback method for systems without this function.
@end deftypefun

@cindex complex trigonometric functions

The trigonometric functions are in mathematics not only defined on real
numbers.  They can be extended to complex numbers and the @w{ISO C 9X}
standard introduces these variants in the standard math library.

@comment complex.h
@comment ISO
@deftypefun {complex double} csin (complex double @var{z})
@deftypefunx {complex float} csinf (complex float @var{z})
@deftypefunx {complex long double} csinl (complex long double @var{z})
These functions return the complex sine of the complex value in @var{z}.
The mathematical definition of the complex sine is

@ifinfo
@math{sin (z) = 1/(2*i) * (exp (z*i) - exp (-z*i))}.
@end ifinfo
@iftex
@tex
$$\sin(z) = {1\over 2i} (e^{zi} - e^{-zi})$$
@end tex
@end iftex
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} ccos (complex double @var{z})
@deftypefunx {complex float} ccosf (complex float @var{z})
@deftypefunx {complex long double} ccosl (complex long double @var{z})
These functions return the complex cosine of the complex value in @var{z}.
The mathematical definition of the complex cosine is

@ifinfo
@math{cos (z) = 1/2 * (exp (z*i) + exp (-z*i))}
@end ifinfo
@iftex
@tex
$$\cos(z) = {1\over 2} (e^{zi} + e^{-zi})$$
@end tex
@end iftex
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} ctan (complex double @var{z})
@deftypefunx {complex float} ctanf (complex float @var{z})
@deftypefunx {complex long double} ctanl (complex long double @var{z})
These functions return the complex tangent of the complex value in @var{z}.
The mathematical definition of the complex tangent is

@ifinfo
@math{tan (z) = 1/i * (exp (z*i) - exp (-z*i)) / (exp (z*i) + exp (-z*i))}
@end ifinfo
@iftex
@tex
$$\tan(z) = {1\over i} {e^{zi} - e^{-zi}\over e^{zi} + e^{-zi}}$$
@end tex
@end iftex
@end deftypefun


@node Inverse Trig Functions
@section Inverse Trigonometric Functions
@cindex inverse trigonometric functions

These are the usual arc sine, arc cosine and arc tangent functions,
which are the inverses of the sine, cosine and tangent functions,
respectively.

@comment math.h
@comment ISO
@deftypefun double asin (double @var{x})
@deftypefunx float asinf (float @var{x})
@deftypefunx {long double} asinl (long double @var{x})
These functions compute the arc sine of @var{x}---that is, the value whose
sine is @var{x}.  The value is in units of radians.  Mathematically,
there are infinitely many such values; the one actually returned is the
one between @code{-pi/2} and @code{pi/2} (inclusive).

@code{asin} fails, and sets @code{errno} to @code{EDOM}, if @var{x} is
out of range.  The arc sine function is defined mathematically only
over the domain @code{-1} to @code{1}.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double acos (double @var{x})
@deftypefunx float acosf (float @var{x})
@deftypefunx {long double} acosl (long double @var{x})
These functions compute the arc cosine of @var{x}---that is, the value
whose cosine is @var{x}.  The value is in units of radians.
Mathematically, there are infinitely many such values; the one actually
returned is the one between @code{0} and @code{pi} (inclusive).

@code{acos} fails, and sets @code{errno} to @code{EDOM}, if @var{x} is
out of range.  The arc cosine function is defined mathematically only
over the domain @code{-1} to @code{1}.
@end deftypefun


@comment math.h
@comment ISO
@deftypefun double atan (double @var{x})
@deftypefunx float atanf (float @var{x})
@deftypefunx {long double} atanl (long double @var{x})
These functions compute the arc tangent of @var{x}---that is, the value
whose tangent is @var{x}.  The value is in units of radians.
Mathematically, there are infinitely many such values; the one actually
returned is the one between @code{-pi/2} and @code{pi/2}
(inclusive).
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double atan2 (double @var{y}, double @var{x})
@deftypefunx float atan2f (float @var{y}, float @var{x})
@deftypefunx {long double} atan2l (long double @var{y}, long double @var{x})
This is the two argument arc tangent function.  It is similar to computing
the arc tangent of @var{y}/@var{x}, except that the signs of both arguments
are used to determine the quadrant of the result, and @var{x} is
permitted to be zero.  The return value is given in radians and is in
the range @code{-pi} to @code{pi}, inclusive.

If @var{x} and @var{y} are coordinates of a point in the plane,
@code{atan2} returns the signed angle between the line from the origin
to that point and the x-axis.  Thus, @code{atan2} is useful for
converting Cartesian coordinates to polar coordinates.  (To compute the
radial coordinate, use @code{hypot}; see @ref{Exponents and
Logarithms}.)

The function @code{atan2} sets @code{errno} to @code{EDOM} if both
@var{x} and @var{y} are zero; the return value is not defined in this
case.
@end deftypefun

@cindex inverse complex trigonometric functions

The inverse trigonometric functions also exist is separate versions
which are usable with complex numbers.

@comment complex.h
@comment ISO
@deftypefun {complex double} casin (complex double @var{z})
@deftypefunx {complex float} casinf (complex float @var{z})
@deftypefunx {complex long double} casinl (complex long double @var{z})
These functions compute the complex arc sine of @var{z}---that is, the
value whose sine is @var{z}.  The value is in units of radians.

Unlike the real version of the arc sine function @code{casin} has no
limitation on the argument @var{z}.
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} cacos (complex double @var{z})
@deftypefunx {complex float} cacosf (complex float @var{z})
@deftypefunx {complex long double} cacosl (complex long double @var{z})
These functions compute the complex arc cosine of @var{z}---that is, the
value whose cosine is @var{z}.  The value is in units of radians.

Unlike the real version of the arc cosine function @code{cacos} has no
limitation on the argument @var{z}.
@end deftypefun


@comment complex.h
@comment ISO
@deftypefun {complex double} catan (complex double @var{z})
@deftypefunx {complex float} catanf (complex float @var{z})
@deftypefunx {complex long double} catanl (complex long double @var{z})
These functions compute the complex arc tangent of @var{z}---that is,
the value whose tangent is @var{z}.  The value is in units of radians.
@end deftypefun


@node Exponents and Logarithms
@section Exponentiation and Logarithms
@cindex exponentiation functions
@cindex power functions
@cindex logarithm functions

@comment math.h
@comment ISO
@deftypefun double exp (double @var{x})
@deftypefunx float expf (float @var{x})
@deftypefunx {long double} expl (long double @var{x})
These functions return the value of @code{e} (the base of natural
logarithms) raised to power @var{x}.

The function fails, and sets @code{errno} to @code{ERANGE}, if the
magnitude of the result is too large to be representable.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double exp2 (double @var{x})
@deftypefunx float exp2f (float @var{x})
@deftypefunx {long double} exp2l (long double @var{x})
These functions return the value of @code{2} raised to the power @var{x}.
Mathematically, @code{exp2 (x)} is the same as @code{exp (x * log (2))}.

The function fails, and sets @code{errno} to @code{ERANGE}, if the
magnitude of the result is too large to be representable.
@end deftypefun

@comment math.h
@comment GNU
@deftypefun double exp10 (double @var{x})
@deftypefunx float exp10f (float @var{x})
@deftypefunx {long double} exp10l (long double @var{x})
@deftypefunx double pow10 (double @var{x})
@deftypefunx float pow10f (float @var{x})
@deftypefunx {long double} pow10l (long double @var{x})
These functions return the value of @code{10} raised to the power @var{x}.
Mathematically, @code{exp2 (x)} is the same as @code{exp (x * log (2))}.

The function fails, and sets @code{errno} to @code{ERANGE}, if the
magnitude of the result is too large to be representable.

All these functions are GNU extensions.  The name @code{pow10} is used
in some old code but the name @code{exp10} clearly is more in the sense
of the ISO library designers and therefore should probably be preferred.
@end deftypefun


@comment math.h
@comment ISO
@deftypefun double log (double @var{x})
@deftypefunx float logf (float @var{x})
@deftypefunx {long double} logl (long double @var{x})
These functions return the natural logarithm of @var{x}.  @code{exp (log
(@var{x}))} equals @var{x}, exactly in mathematics and approximately in
C.

The following @code{errno} error conditions are defined for this function:

@table @code
@item EDOM
The argument @var{x} is negative.  The log function is defined
mathematically to return a real result only on positive arguments.

@item ERANGE
The argument is zero.  The log of zero is not defined.
@end table
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double log10 (double @var{x})
@deftypefunx float log10f (float @var{x})
@deftypefunx {long double} log10l (long double @var{x})
These functions return the base-10 logarithm of @var{x}.  Except for the
different base, it is similar to the @code{log} function.  In fact,
@code{log10 (@var{x})} equals @code{log (@var{x}) / log (10)}.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double log2 (double @var{x})
@deftypefunx float log2f (float @var{x})
@deftypefunx {long double} log2l (long double @var{x})
These functions return the base-2 logarithm of @var{x}.  Except for the
different base, it is similar to the @code{log} function.  In fact,
@code{log2 (@var{x})} equals @code{log (@var{x}) / log (2)}.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double logb (double @var{x})
@deftypefunx float logbf (float @var{x})
@deftypefunx {long double} logbl (long double @var{x})
These functions extract the exponent of @var{x} and return it as a
signed integer value.  If @var{x} is zero, a range error may occur.

A special case are subnormal numbers (if supported by the floating-point
format).  The exponent returned is not the actual value from @var{x}.
Instead the number is first normalized as if the range of the exponent
field is large enough.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun int ilogb (double @var{x})
@deftypefunx int ilogbf (float @var{x})
@deftypefunx int ilogbl (long double @var{x})
These functions are equivalent to the corresponding @code{logb}
functions except that the values are returned as signed integer values.
Since integer values cannot represent infinity and NaN, there are some
special symbols defined to help detect these situations.

@vindex FP_ILOGB0
@vindex FP_ILOGBNAN
@code{ilogb} returns @code{FP_ILOGB0} if @var{x} is @code{0} and it
returns @code{FP_ILOGBNAN} if @var{x} is @code{NaN}.  These values are
system specific and no fixed value is assigned.  More concrete, these
values might even have the same value.  So a piece of code handling the
result of @code{ilogb} could look like this:

@smallexample
i = ilogb (f);
if (i == FP_ILOGB0 || i == FP_ILOGBNAN)
  @{
    if (isnan (f))
      @{
        /* @r{Handle NaN.}  */
      @}
    else if (f  == 0.0)
      @{
        /* @r{Handle 0.0.}  */
      @}
    else
      @{
        /* @r{Some other value with large exponent,}
           @r{perhaps +Inf.}  */
      @}
  @}
@end smallexample

@end deftypefun

@comment math.h
@comment ISO
@deftypefun double pow (double @var{base}, double @var{power})
@deftypefunx float powf (float @var{base}, float @var{power})
@deftypefunx {long double} powl (long double @var{base}, long double @var{power})
These are general exponentiation functions, returning @var{base} raised
to @var{power}.

@need 250
The following @code{errno} error conditions are defined for this function:

@table @code
@item EDOM
The argument @var{base} is negative and @var{power} is not an integral
value.  Mathematically, the result would be a complex number in this case.

@item ERANGE
An underflow or overflow condition was detected in the result.
@end table
@end deftypefun

@cindex square root function
@comment math.h
@comment ISO
@deftypefun double sqrt (double @var{x})
@deftypefunx float sqrtf (float @var{x})
@deftypefunx {long double} sqrtl (long double @var{x})
These functions return the nonnegative square root of @var{x}.

The @code{sqrt} function fails, and sets @code{errno} to @code{EDOM}, if
@var{x} is negative.  Mathematically, the square root would be a complex
number.
@c (@pxref{csqrt})
@end deftypefun

@cindex cube root function
@comment math.h
@comment BSD
@deftypefun double cbrt (double @var{x})
@deftypefunx float cbrtf (float @var{x})
@deftypefunx {long double} cbrtl (long double @var{x})
These functions return the cube root of @var{x}.  They cannot
fail; every representable real value has a representable real cube root.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double hypot (double @var{x}, double @var{y})
@deftypefunx float hypotf (float @var{x}, float @var{y})
@deftypefunx {long double} hypotl (long double @var{x}, long double @var{y})
These functions return @code{sqrt (@var{x}*@var{x} +
@var{y}*@var{y})}.  (This is the length of the hypotenuse of a right
triangle with sides of length @var{x} and @var{y}, or the distance
of the point (@var{x}, @var{y}) from the origin.)  Using this function
instead of the direct formula is highly appreciated since the error is
much smaller.  See also the function @code{cabs} in @ref{Absolute Value}.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double expm1 (double @var{x})
@deftypefunx float expm1f (float @var{x})
@deftypefunx {long double} expm1l (long double @var{x})
These functions return a value equivalent to @code{exp (@var{x}) - 1}.
It is computed in a way that is accurate even if the value of @var{x} is
near zero---a case where @code{exp (@var{x}) - 1} would be inaccurate due
to subtraction of two numbers that are nearly equal.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double log1p (double @var{x})
@deftypefunx float log1pf (float @var{x})
@deftypefunx {long double} log1pl (long double @var{x})
This function returns a value equivalent to @w{@code{log (1 + @var{x})}}.
It is computed in a way that is accurate even if the value of @var{x} is
near zero.
@end deftypefun

@cindex complex exponentiation functions
@cindex complex logarithm functions

@w{ISO C 9X} defines variants of some of the exponentiation and
logarithm functions.  As for the other functions handling complex
numbers these functions are perhaps better optimized and provide better
error checking than a direct use of the formulas of the mathematical
definition.

@comment complex.h
@comment ISO
@deftypefun {complex double} cexp (complex double @var{z})
@deftypefunx {complex float} cexpf (complex float @var{z})
@deftypefunx {complex long double} cexpl (complex long double @var{z})
These functions return the value of @code{e} (the base of natural
logarithms) raised to power of the complex value @var{z}.

@noindent
Mathematically this corresponds to the value

@ifinfo
@math{exp (z) = exp (creal (z)) * (cos (cimag (z)) + I * sin (cimag (z)))}
@end ifinfo
@iftex
@tex
$$\exp(z) = e^z = e^{{\rm Re} z} (\cos ({\rm Im} z) + i \sin ({\rm Im} z))$$
@end tex
@end iftex
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} clog (complex double @var{z})
@deftypefunx {complex float} clogf (complex float @var{z})
@deftypefunx {complex long double} clogl (complex long double @var{z})
These functions return the natural logarithm of the complex value
@var{z}.  Unlike the real value version @code{log} and its variants,
@code{clog} has no limit for the range of its argument @var{z}.

@noindent
Mathematically this corresponds to the value

@ifinfo
@math{log (z) = log (cabs (z)) + I * carg (z)}
@end ifinfo
@iftex
@tex
$$\log(z) = \log(|z|) + i \arg(z)$$
@end tex
@end iftex
@end deftypefun


@comment complex.h
@comment GNU
@deftypefun {complex double} clog10 (complex double @var{z})
@deftypefunx {complex float} clog10f (complex float @var{z})
@deftypefunx {complex long double} clog10l (complex long double @var{z})
These functions return the base 10 logarithm of the complex value
@var{z}.  Unlike the real value version @code{log} and its variants,
@code{clog} has no limit for the range of its argument @var{z}.

@noindent
Mathematically this corresponds to the value

@ifinfo
@math{log (z) = log10 (cabs (z)) + I * carg (z)}
@end ifinfo
@iftex
@tex
$$\log_{10}(z) = \log_{10}(|z|) + i \arg(z)$$
@end tex
@end iftex

This function is a GNU extension.
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} csqrt (complex double @var{z})
@deftypefunx {complex float} csqrtf (complex float @var{z})
@deftypefunx {complex long double} csqrtl (complex long double @var{z})
These functions return the complex root of the argument @var{z}.  Unlike
the @code{sqrt} function these functions do not have any restriction on
the value of the argument.
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} cpow (complex double @var{base}, complex double @var{power})
@deftypefunx {complex float} cpowf (complex float @var{base}, complex float @var{power})
@deftypefunx {complex long double} cpowl (complex long double @var{base}, complex long double @var{power})
These functions return the complex value @var{base} raised to the power of
@var{power}.  This is computed as

@ifinfo
@math{cpow (x, y) = cexp (y * clog (x))}
@end ifinfo
@iftex
@tex
$${\rm cpow}(x, y) = e^{y \log(x)}$$
@end tex
@end iftex
@end deftypefun


@node Hyperbolic Functions
@section Hyperbolic Functions
@cindex hyperbolic functions

The functions in this section are related to the exponential functions;
see @ref{Exponents and Logarithms}.

@comment math.h
@comment ISO
@deftypefun double sinh (double @var{x})
@deftypefunx float sinhf (float @var{x})
@deftypefunx {long double} sinhl (long double @var{x})
These functions return the hyperbolic sine of @var{x}, defined
mathematically as @w{@code{(exp (@var{x}) - exp (-@var{x})) / 2}}.  The
function fails, and sets @code{errno} to @code{ERANGE}, if the value of
@var{x} is too large; that is, if overflow occurs.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double cosh (double @var{x})
@deftypefunx float coshf (float @var{x})
@deftypefunx {long double} coshl (long double @var{x})
These function return the hyperbolic cosine of @var{x},
defined mathematically as @w{@code{(exp (@var{x}) + exp (-@var{x})) / 2}}.
The function fails, and sets @code{errno} to @code{ERANGE}, if the value
of @var{x} is too large; that is, if overflow occurs.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double tanh (double @var{x})
@deftypefunx float tanhf (float @var{x})
@deftypefunx {long double} tanhl (long double @var{x})
These functions return the hyperbolic tangent of @var{x}, whose
mathematical definition is @w{@code{sinh (@var{x}) / cosh (@var{x})}}.
@end deftypefun

@cindex hyperbolic functions

There are counterparts for these hyperbolic functions which work with
complex valued arguments.  They should always be used instead of the
obvious mathematical formula since the implementations in the math
library are optimized for accuracy and speed.

@comment complex.h
@comment ISO
@deftypefun {complex double} csinh (complex double @var{z})
@deftypefunx {complex float} csinhf (complex float @var{z})
@deftypefunx {complex long double} csinhl (complex long double @var{z})
These functions return the complex hyperbolic sine of @var{z}, defined
mathematically as @w{@code{(exp (@var{z}) - exp (-@var{z})) / 2}}.  The
function fails, and sets @code{errno} to @code{ERANGE}, if the value of
result is too large.
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} ccosh (complex double @var{z})
@deftypefunx {complex float} ccoshf (complex float @var{z})
@deftypefunx {complex long double} ccoshl (complex long double @var{z})
These functions return the complex hyperbolic cosine of @var{z}, defined
mathematically as @w{@code{(exp (@var{z}) + exp (-@var{z})) / 2}}.  The
function fails, and sets @code{errno} to @code{ERANGE}, if the value of
result is too large.
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} ctanh (complex double @var{z})
@deftypefunx {complex float} ctanhf (complex float @var{z})
@deftypefunx {complex long double} ctanhl (complex long double @var{z})
These functions return the complex hyperbolic tangent of @var{z}, whose
mathematical definition is @w{@code{csinh (@var{z}) / ccosh (@var{z})}}.
@end deftypefun


@cindex inverse hyperbolic functions

@comment math.h
@comment ISO
@deftypefun double asinh (double @var{x})
@deftypefunx float asinhf (float @var{x})
@deftypefunx {long double} asinhl (long double @var{x})
These functions return the inverse hyperbolic sine of @var{x}---the
value whose hyperbolic sine is @var{x}.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double acosh (double @var{x})
@deftypefunx float acoshf (float @var{x})
@deftypefunx {long double} acoshl (long double @var{x})
These functions return the inverse hyperbolic cosine of @var{x}---the
value whose hyperbolic cosine is @var{x}.  If @var{x} is less than
@code{1}, @code{acosh} returns @code{HUGE_VAL}.
@end deftypefun

@comment math.h
@comment ISO
@deftypefun double atanh (double @var{x})
@deftypefunx float atanhf (float @var{x})
@deftypefunx {long double} atanhl (long double @var{x})
These functions return the inverse hyperbolic tangent of @var{x}---the
value whose hyperbolic tangent is @var{x}.  If the absolute value of
@var{x} is greater than or equal to @code{1}, @code{atanh} returns
@code{HUGE_VAL}.
@end deftypefun

@cindex inverse complex hyperbolic functions

@comment complex.h
@comment ISO
@deftypefun {complex double} casinh (complex double @var{z})
@deftypefunx {complex float} casinhf (complex float @var{z})
@deftypefunx {complex long double} casinhl (complex long double @var{z})
These functions return the inverse complex hyperbolic sine of
@var{z}---the value whose complex hyperbolic sine is @var{z}.
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} cacosh (complex double @var{z})
@deftypefunx {complex float} cacoshf (complex float @var{z})
@deftypefunx {complex long double} cacoshl (complex long double @var{z})
These functions return the inverse complex hyperbolic cosine of
@var{z}---the value whose complex hyperbolic cosine is @var{z}.  Unlike
the real valued function @code{acosh} there is not limit for the range
of the argument.
@end deftypefun

@comment complex.h
@comment ISO
@deftypefun {complex double} catanh (complex double @var{z})
@deftypefunx {complex float} catanhf (complex float @var{z})
@deftypefunx {complex long double} catanhl (complex long double @var{z})
These functions return the inverse complex hyperbolic tangent of
@var{z}---the value whose complex hyperbolic tangent is @var{z}.  Unlike
the real valued function @code{atanh} there is not limit for the range
of the argument.
@end deftypefun


@node Pseudo-Random Numbers
@section Pseudo-Random Numbers
@cindex random numbers
@cindex pseudo-random numbers
@cindex seed (for random numbers)

This section describes the GNU facilities for generating a series of
pseudo-random numbers.  The numbers generated are not truly random;
typically, they form a sequence that repeats periodically, with a
period so large that you can ignore it for ordinary purposes.  The
random number generator works by remembering at all times a @dfn{seed}
value which it uses to compute the next random number and also to
compute a new seed.

Although the generated numbers look unpredictable within one run of a
program, the sequence of numbers is @emph{exactly the same} from one run
to the next.  This is because the initial seed is always the same.  This
is convenient when you are debugging a program, but it is unhelpful if
you want the program to behave unpredictably.  If you want truly random
numbers, not just pseudo-random, specify a seed based on the current
time.

You can get repeatable sequences of numbers on a particular machine type
by specifying the same initial seed value for the random number
generator.  There is no standard meaning for a particular seed value;
the same seed, used in different C libraries or on different CPU types,
will give you different random numbers.

The GNU library supports the standard @w{ISO C} random number functions
plus two other sets derived from BSD and SVID.  We recommend you use the
standard ones, @code{rand} and @code{srand} if only a small number of
random bits are required.  The SVID functions provide an interface which
allows better random number generator algorithms and they return up to
48 random bits in one calls and they also return random floating-point
numbers if wanted.  The SVID function might not be available on some BSD
derived systems but since they are required in the XPG they are
available on all Unix-conformant systems.

@menu
* ISO Random::       @code{rand} and friends.
* BSD Random::       @code{random} and friends.
* SVID Random::      @code{drand48} and friends.
@end menu

@node ISO Random
@subsection ISO C Random Number Functions

This section describes the random number functions that are part of
the @w{ISO C} standard.

To use these facilities, you should include the header file
@file{stdlib.h} in your program.
@pindex stdlib.h

@comment stdlib.h
@comment ISO
@deftypevr Macro int RAND_MAX
The value of this macro is an integer constant expression that
represents the maximum possible value returned by the @code{rand}
function.  In the GNU library, it is @code{037777777}, which is the
largest signed integer representable in 32 bits.  In other libraries, it
may be as low as @code{32767}.
@end deftypevr

@comment stdlib.h
@comment ISO
@deftypefun int rand (void)
The @code{rand} function returns the next pseudo-random number in the
series.  The value is in the range from @code{0} to @code{RAND_MAX}.
@end deftypefun

@comment stdlib.h
@comment ISO
@deftypefun void srand (unsigned int @var{seed})
This function establishes @var{seed} as the seed for a new series of
pseudo-random numbers.  If you call @code{rand} before a seed has been
established with @code{srand}, it uses the value @code{1} as a default
seed.

To produce truly random numbers (not just pseudo-random), do @code{srand
(time (0))}.
@end deftypefun

A completely broken interface was designed by the POSIX.1 committee to
support reproducible random numbers in multi-threaded programs.

@comment stdlib.h
@comment POSIX.1
@deftypefun int rand_r (unsigned int *@var{seed})
This function returns a random number in the range 0 to @code{RAND_MAX}
just as @code{rand} does.  But this function does not keep an internal
state for the RNG.  Instead the @code{unsigned int} variable pointed to
by the argument @var{seed} is the only state.  Before the value is
returned the state will be updated so that the next call will return a
new number.

I.e., the state of the RNG can only have as much bits as the type
@code{unsigned int} has.  This is far too few to provide a good RNG.
This interface is broken by design.

If the program requires reproducible random numbers in multi-threaded
programs the reentrant SVID functions are probably a better choice.  But
these functions are GNU extensions and therefore @code{rand_r}, as being
standardized in POSIX.1, should always be kept as a default method.
@end deftypefun


@node BSD Random
@subsection BSD Random Number Functions

This section describes a set of random number generation functions that
are derived from BSD.  There is no advantage to using these functions
with the GNU C library; we support them for BSD compatibility only.

The prototypes for these functions are in @file{stdlib.h}.
@pindex stdlib.h

@comment stdlib.h
@comment BSD
@deftypefun {int32_t} random (void)
This function returns the next pseudo-random number in the sequence.
The range of values returned is from @code{0} to @code{RAND_MAX}.

@strong{Please note:} Historically this function returned a @code{long
int} value.  But with the appearance of 64bit machines this could lead
to severe compatibility problems and therefore the type now explicitly
limits the return value to 32bit.
@end deftypefun

@comment stdlib.h
@comment BSD
@deftypefun void srandom (unsigned int @var{seed})
The @code{srandom} function sets the seed for the current random number
state based on the integer @var{seed}.  If you supply a @var{seed} value
of @code{1}, this will cause @code{random} to reproduce the default set
of random numbers.

To produce truly random numbers (not just pseudo-random), do
@code{srandom (time (0))}.
@end deftypefun

@comment stdlib.h
@comment BSD
@deftypefun {void *} initstate (unsigned int @var{seed}, void *@var{state}, size_t @var{size})
The @code{initstate} function is used to initialize the random number
generator state.  The argument @var{state} is an array of @var{size}
bytes, used to hold the state information.  The size must be at least 8
bytes, and optimal sizes are 8, 16, 32, 64, 128, and 256.  The bigger
the @var{state} array, the better.

The return value is the previous value of the state information array.
You can use this value later as an argument to @code{setstate} to
restore that state.
@end deftypefun

@comment stdlib.h
@comment BSD
@deftypefun {void *} setstate (void *@var{state})
The @code{setstate} function restores the random number state
information @var{state}.  The argument must have been the result of
a previous call to @var{initstate} or @var{setstate}.

The return value is the previous value of the state information array.
You can use this value later as an argument to @code{setstate} to
restore that state.
@end deftypefun


@node SVID Random
@subsection SVID Random Number Function

The C library on SVID systems contains yet another kind of random number
generator functions.  They use a state of 48 bits of data.  The user can
choose among a collection of functions which all return the random bits
in different forms.

Generally there are two kinds of functions: those which use a state of
the random number generator which is shared among several functions and
by all threads of the process.  The second group of functions require
the user to handle the state.

All functions have in common that they use the same congruential
formula with the same constants.  The formula is

@smallexample
Y = (a * X + c) mod m
@end smallexample

@noindent
where @var{X} is the state of the generator at the beginning and
@var{Y} the state at the end.  @code{a} and @code{c} are constants
determining the way the generator work.  By default they are

@smallexample
a = 0x5DEECE66D = 25214903917
c = 0xb = 11
@end smallexample

@noindent
but they can also be changed by the user.  @code{m} is of course 2^48
since the state consists of a 48 bit array.


@comment stdlib.h
@comment SVID
@deftypefun double drand48 (void)
This function returns a @code{double} value in the range of @code{0.0}
to @code{1.0} (exclusive).  The random bits are determined by the global
state of the random number generator in the C library.

Since the @code{double} type according to @w{IEEE 754} has a 52 bit
mantissa this means 4 bits are not initialized by the random number
generator.  These are (of course) chosen to be the least significant
bits and they are initialized to @code{0}.
@end deftypefun

@comment stdlib.h
@comment SVID
@deftypefun double erand48 (unsigned short int @var{xsubi}[3])
This function returns a @code{double} value in the range of @code{0.0}
to @code{1.0} (exclusive), similar to @code{drand48}.  The argument is
an array describing the state of the random number generator.

This function can be called subsequently since it updates the array to
guarantee random numbers.  The array should have been initialized before
using to get reproducible results.
@end deftypefun

@comment stdlib.h
@comment SVID
@deftypefun {long int} lrand48 (void)
The @code{lrand48} functions return an integer value in the range of
@code{0} to @code{2^31} (exclusive).  Even if the size of the @code{long
int} type can take more than 32 bits no higher numbers are returned.
The random bits are determined by the global state of the random number
generator in the C library.
@end deftypefun

@comment stdlib.h
@comment SVID
@deftypefun {long int} nrand48 (unsigned short int @var{xsubi}[3])
This function is similar to the @code{lrand48} function in that it
returns a number in the range of @code{0} to @code{2^31} (exclusive) but
the state of the random number generator used to produce the random bits
is determined by the array provided as the parameter to the function.

The numbers in the array are afterwards updated so that subsequent calls
to this function yield to different results (as it is expected by a
random number generator).  The array should have been initialized before
the first call to get reproducible results.
@end deftypefun

@comment stdlib.h
@comment SVID
@deftypefun {long int} mrand48 (void)
The @code{mrand48} function is similar to @code{lrand48}.  The only
difference is that the numbers returned are in the range @code{-2^31} to
@code{2^31} (exclusive).
@end deftypefun

@comment stdlib.h
@comment SVID
@deftypefun {long int} jrand48 (unsigned short int @var{xsubi}[3])
The @code{jrand48} function is similar to @code{nrand48}.  The only
difference is that the numbers returned are in the range @code{-2^31} to
@code{2^31} (exclusive).  For the @code{xsubi} parameter the same
requirements are necessary.
@end deftypefun

The internal state of the random number generator can be initialized in
several ways.  The functions differ in the completeness of the
information provided.

@comment stdlib.h
@comment SVID
@deftypefun void srand48 (long int @var{seedval}))
The @code{srand48} function sets the most significant 32 bits of the
state internal state of the random number generator to the least
significant 32 bits of the @var{seedval} parameter.  The lower 16 bits
are initialized to the value @code{0x330E}.  Even if the @code{long
int} type contains more the 32 bits only the lower 32 bits are used.

Due to this limitation the initialization of the state using this
function of not very useful.  But it makes it easy to use a construct
like @code{srand48 (time (0))}.

A side-effect of this function is that the values @code{a} and @code{c}
from the internal state, which are used in the congruential formula,
are reset to the default values given above.  This is of importance once
the user called the @code{lcong48} function (see below).
@end deftypefun

@comment stdlib.h
@comment SVID
@deftypefun {unsigned short int *} seed48 (unsigned short int @var{seed16v}[3])
The @code{seed48} function initializes all 48 bits of the state of the
internal random number generator from the content of the parameter
@var{seed16v}.  Here the lower 16 bits of the first element of
@var{see16v} initialize the least significant 16 bits of the internal
state, the lower 16 bits of @code{@var{seed16v}[1]} initialize the mid-order
16 bits of the state and the 16 lower bits of @code{@var{seed16v}[2]}
initialize the most significant 16 bits of the state.

Unlike @code{srand48} this function lets the user initialize all 48 bits
of the state.

The value returned by @code{seed48} is a pointer to an array containing
the values of the internal state before the change.  This might be
useful to restart the random number generator at a certain state.
Otherwise, the value can simply be ignored.

As for @code{srand48}, the values @code{a} and @code{c} from the
congruential formula are reset to the default values.
@end deftypefun

There is one more function to initialize the random number generator
which allows to specify even more information by allowing to change the
parameters in the congruential formula.

@comment stdlib.h
@comment SVID
@deftypefun void lcong48 (unsigned short int @var{param}[7])
The @code{lcong48} function allows the user to change the complete state
of the random number generator.  Unlike @code{srand48} and
@code{seed48}, this function also changes the constants in the
congruential formula.

From the seven elements in the array @var{param} the least significant
16 bits of the entries @code{@var{param}[0]} to @code{@var{param}[2]}
determine the initial state, the least 16 bits of
@code{@var{param}[3]} to @code{@var{param}[5]} determine the 48 bit
constant @code{a} and @code{@var{param}[6]} determines the 16 bit value
@code{c}.
@end deftypefun

All the above functions have in common that they use the global
parameters for the congruential formula.  In multi-threaded programs it
might sometimes be useful to have different parameters in different
threads.  For this reason all the above functions have a counterpart
which works on a description of the random number generator in the
user-supplied buffer instead of the global state.

Please note that it is no problem if several threads use the global
state if all threads use the functions which take a pointer to an array
containing the state.  The random numbers are computed following the
same loop but if the state in the array is different all threads will
get an individual random number generator.

The user supplied buffer must be of type @code{struct drand48_data}.
This type should be regarded as opaque and no member should be used
directly.

@comment stdlib.h
@comment GNU
@deftypefun int drand48_r (struct drand48_data *@var{buffer}, double *@var{result})
This function is equivalent to the @code{drand48} function with the
difference it does not modify the global random number generator
parameters but instead the parameters is the buffer supplied by the
buffer through the pointer @var{buffer}.  The random number is return in
the variable pointed to by @var{result}.

The return value of the function indicate whether the call succeeded.
If the value is less than @code{0} an error occurred and @var{errno} is
set to indicate the problem.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun int erand48_r (unsigned short int @var{xsubi}[3], struct drand48_data *@var{buffer}, double *@var{result})
The @code{erand48_r} function works like the @code{erand48} and it takes
an argument @var{buffer} which describes the random number generator.
The state of the random number generator is taken from the @code{xsubi}
array, the parameters for the congruential formula from the global
random number generator data.  The random number is return in the
variable pointed to by @var{result}.

The return value is non-negative is the call succeeded.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun int lrand48_r (struct drand48_data *@var{buffer}, double *@var{result})
This function is similar to @code{lrand48} and it takes a pointer to a
buffer describing the state of the random number generator as a
parameter just like @code{drand48}.

If the return value of the function is non-negative the variable pointed
to by @var{result} contains the result.  Otherwise an error occurred.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun int nrand48_r (unsigned short int @var{xsubi}[3], struct drand48_data *@var{buffer}, long int *@var{result})
The @code{nrand48_r} function works like @code{nrand48} in that it
produces a random number in range @code{0} to @code{2^31}.  But instead
of using the global parameters for the congruential formula it uses the
information from the buffer pointed to by @var{buffer}.  The state is
described by the values in @var{xsubi}.

If the return value is non-negative the variable pointed to by
@var{result} contains the result.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun int mrand48_r (struct drand48_data *@var{buffer}, double *@var{result})
This function is similar to @code{mrand48} but as the other reentrant
function it uses the random number generator described by the value in
the buffer pointed to by @var{buffer}.

If the return value is non-negative the variable pointed to by
@var{result} contains the result.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun int jrand48_r (unsigned short int @var{xsubi}[3], struct drand48_data *@var{buffer}, long int *@var{result})
The @code{jrand48_r} function is similar to @code{jrand48}.  But as the
other reentrant functions of this function family it uses the
congruential formula parameters from the buffer pointed to by
@var{buffer}.

If the return value is non-negative the variable pointed to by
@var{result} contains the result.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun

Before any of the above functions should be used the buffer of type
@code{struct drand48_data} should initialized.  The easiest way is to
fill the whole buffer with null bytes, e.g., using

@smallexample
memset (buffer, '\0', sizeof (struct drand48_data));
@end smallexample

@noindent
Using any of the reentrant functions of this family now will
automatically initialize the random number generator to the default
values for the state and the parameters of the congruential formula.

The other possibility is too use any of the functions which explicitely
initialize the buffer.  Though it might be obvious how to initialize the
buffer from the data given as parameter from the function it is highly
recommended to use these functions since the result might not always be
what you expect.

@comment stdlib.h
@comment GNU
@deftypefun int srand48_r (long int @var{seedval}, struct drand48_data *@var{buffer})
The description of the random number generator represented by the
information in @var{buffer} is initialized similar to what the function
@code{srand48} does.  The state is initialized from the parameter
@var{seedval} and the parameters for the congruential formula are
initialized to the default values.

If the return value is non-negative the function call succeeded.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun int seed48_r (unsigned short int @var{seed16v}[3], struct drand48_data *@var{buffer})
This function is similar to @code{srand48_r} but like @code{seed48} it
initializes all 48 bits of the state from the parameter @var{seed16v}.

If the return value is non-negative the function call succeeded.  It
does not return a pointer to the previous state of the random number
generator like the @code{seed48} function does.  if the user wants to
preserve the state for a later rerun s/he can copy the whole buffer
pointed to by @var{buffer}.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun int lcong48_r (unsigned short int @var{param}[7], struct drand48_data *@var{buffer})
This function initializes all aspects of the random number generator
described in @var{buffer} by the data in @var{param}.  Here it is
especially true the function does more than just copying the contents of
@var{param} of @var{buffer}.  Some more actions are required and
therefore it is important to use this function and not initialized the
random number generator directly.

If the return value is non-negative the function call succeeded.

This function is a GNU extension and should not be used in portable
programs.
@end deftypefun
