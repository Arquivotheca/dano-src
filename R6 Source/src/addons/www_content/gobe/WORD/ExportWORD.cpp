//
//	ExportWORD.cpp
//

#include "ExportWORD.h"
#include "WORDStaticStreams.h"

#define UNICODE_OUT


#define TEXTRUN_BUFFER_SIZE	1024

// From WinWord97, here are the streams you get when saving a document
// which just has some simple text in it
//
// Root Entry - 0x0080, 5
//
// 1Table - 0x1000, 2
//		lots of tables, including style sheets,
//		CHP and PAP bin tables, and font names
//
// WordDocument	- 0x1000, 2
//		FIB
//		TEXT (body, footnote, header)
//		FKP's
//			CHP (starts at 512k boundary after last text byte
//			PAP
//			LVC
//		SEPX's
//
// SummaryInformation			- 0x1000, 2
//
// DocumentSummaryInformation	- 0x1000, 2
//
// CompObj						- 0x006a, 2
//


//-------------------------------------------------------------------
// TExportWORD
//-------------------------------------------------------------------

TExportWORD::TExportWORD(TBlockStreamReader* reader, BPositionIO *outStream)
{
	mReader = reader;
	mOutStream = outStream;

	mBlankStyle = new TTranslatorStyle;
	
	mOutFile = dynamic_cast<BFile*>(mOutStream);
	if (mOutFile)
	{
		BNodeInfo nodeInfo(mOutFile);	
		nodeInfo.SetType("application/msword");
	}
	
	mBufferMaxSize = INIT_BUFFER_SIZE;
	mBuffer = new char[mBufferMaxSize];
	mBufferSize = 0;
	
	mOleWriter = new TOLEWriter(mOutFile);
	
	mBytesTextWritten = 0;
	
	mZeroBlock = new char[BLOCKSIZE];
	memset(mZeroBlock, 0, BLOCKSIZE);

	mFootnoteTbl = new TFootnoteTblWord;
	mEndnoteTbl = new TFootnoteTblWord;
	
	mHeaderPartPtr = 0;
	mFooterPartPtr = 0;
	mLastParaStyle = 0;
	mLastCharStyle = 0;
}


TExportWORD::~TExportWORD()
{
	delete [] mBuffer;
	delete [] mZeroBlock;	
	
	delete mBlankStyle;
	delete mFontTbl;
	delete mStyleTbl;
	delete mFKP_PAPX;
	delete mFKP_CHPX;
	delete mFootnoteTbl;
	delete mEndnoteTbl;
}


int32 TExportWORD::DoTranslate(void)
{	
	// Read in the translator document.
	status_t err = mTransDoc.Read( mReader );
	if (err)
		return err;
	
	// Get the active sheets main part.
	int32 sheetIndex = mTransDoc.ActiveSheetIndex();
	const TTranslatorSheet* sheetPtr = mTransDoc.SheetPtr( sheetIndex );
	if (sheetPtr)
	{
		mPartPtr = dynamic_cast<const TTranslatorPart_WP*>(sheetPtr->MainPartPtr());
		mMainPartPtr = dynamic_cast<const TTranslatorPart_WP*>(sheetPtr->MainPartPtr());
		mHeaderPartPtr = dynamic_cast<const TTranslatorPart_WP*>(sheetPtr->HeaderPartPtr());
		mFooterPartPtr = dynamic_cast<const TTranslatorPart_WP*>(sheetPtr->FooterPartPtr());
	}
	if (!mPartPtr)
		return B_ERROR;
	
	// Create all ole entries (streams)
	createAllEntries();
	
	initFIB();
	initDOP();
	
	WriteKnownStreams();
	
	setEntryPosition(mWriterMain, 1024);
	
	mFontTbl = new TFontTblWORD();
	mStyleTbl = new TStyleSheetWORD();
	
	mStyleTbl->AddStyleTable(mTransDoc.StylesTable(), mFontTbl);
	
	mFKP_PAPX = new TPAPXExportTbl(mWriterMain, mWriterTable);
	mFKP_PAPX->setFirstFC(1024);
	
	mFKP_CHPX = new TCHPXExportTbl(mWriterMain, mWriterTable);
	mFKP_CHPX->setFirstFC(1024);
	
	processPart(mPartPtr, mFIBLong[ccpText]);

	mStyleTbl->Write(mWriterTable, mFIBPair[Stshf].theLong, mFIBPair[Stshf].theULong);

	//writeNotes();
	writeSED();
	writeHeaders();
	
	mWriterMain->SetStreamPos(mWriterMain->StreamDataSize());
	mFKP_CHPX->write(&(mFIBPair[PlcfbteChpx].theLong), &(mFIBPair[PlcfbteChpx].theULong));
	
	//mFIBLong[pnChpFirst] = mFKP_CHPX->firstPN(); // word doesn't write these out, why shoould I? just to make me happy.
	//mFIBLong[cpnBteChp] = mFKP_CHPX->numFkps();
	
	
	mWriterMain->SetStreamPos(mWriterMain->StreamDataSize());
	mFKP_PAPX->write(&(mFIBPair[PlcfbtePapx].theLong), &(mFIBPair[PlcfbtePapx].theULong));
	//mFIBLong[pnPapFirst] = mFKP_PAPX->firstPN(); // word doesn't write these out, why shoould I? just to make me happy.
	//mFIBLong[cpnBtePap] = mFKP_PAPX->numFkps();
	
	writeLVC();
	
	mFIBPair[Plcfgram].theLong = mWriterTable->GetStreamPos();
	mFIBPair[Plcfgram].theULong = sizeof(GramState);
	mWriterTable->WriteBytes(GramState, sizeof(GramState));
	
	mFIBPair[SttbSavedBy].theLong = mWriterTable->GetStreamPos();
	mFIBPair[SttbSavedBy].theULong = sizeof(SavedBy);
	mWriterTable->WriteBytes(SavedBy, sizeof(SavedBy));
	
	mFIBPair[Cmds].theLong = mWriterTable->GetStreamPos();
	mFIBPair[Cmds].theULong = sizeof(CmdsArr);
	mWriterTable->WriteBytes(CmdsArr, sizeof(CmdsArr));
	
	mFIBPair[Wss].theLong = mWriterTable->GetStreamPos();
	mFIBPair[Wss].theULong = sizeof(WssArr);
	mWriterTable->WriteBytes(WssArr, sizeof(WssArr));

	writePieceTable();
	
	mFontTbl->Write(mWriterTable, mFIBPair[Sttbfffn].theLong, mFIBPair[Sttbfffn].theULong);
	
	writeDOP();
		
	IFDEBUG(fprintf(stderr, "\nmFIBPair[PlcfbteChpx].theLong = %d\n", mFIBPair[PlcfbteChpx].theLong));
	IFDEBUG(fprintf(stderr, "mFIBPair[PlcfbtePapx].theLong = %d\n", mFIBPair[PlcfbtePapx].theLong));
	
	mFIBLong[cbMac] = mWriterMain->StreamDataSize();

	writeFIB();
	
	setEntryPosition(mWriterTable, 0x01000);


	
	mOleWriter->DocumentComplete();
			
    return B_OK;
}


// These are in the order of sample doc w97simple.doc from WinWord97
void TExportWORD::createAllEntries()
{
	mIndexRoot = 0;		// by default when creating mOleWriter
	mIndexSumInfo = mOleWriter->NewChildEntry(2, "SummaryInformation", mIndexRoot);
	mIndexDocSumInfo = mOleWriter->NewNextEntry(2, "DocumentSummaryInformation", mIndexSumInfo);
	mIndexMain = mOleWriter->NewPrevEntry(2, "WordDocument", mIndexSumInfo);
	mIndexTable = mOleWriter->NewPrevEntry(2, "1Table", mIndexMain);
	mIndexCompObj = mOleWriter->NewNextEntry(2, "CompObj", mIndexTable);
	
	mWriterMain = mOleWriter->EntryWriter(mIndexMain);
	mWriterTable = mOleWriter->EntryWriter(mIndexTable);
}

int32 TExportWORD::setEntryPosition(TOLEEntryWriter* entryWriter, int32 pos)
{
	char zero = 0;
	if (entryWriter->StreamDataSize() < pos)
	{
		entryWriter->SetStreamPos(entryWriter->StreamDataSize());
		while (entryWriter->StreamDataSize() < pos)
			entryWriter->WriteBytes(&zero, 1);

	}
	else
		entryWriter->SetStreamPos(pos);
	
	
    return B_OK;
}


void TExportWORD::WriteKnownStreams()
{
	TOLEEntryWriter *	entryWriter;
	
	entryWriter = mOleWriter->EntryWriter(mIndexSumInfo);
	entryWriter->WriteBytes(&SummaryInformationOLEStream[0], sizeof(SummaryInformationOLEStream));	
	
	entryWriter = mOleWriter->EntryWriter(mIndexDocSumInfo);
	entryWriter->WriteBytes(&DocumentSummaryInformationOLEStream[0], sizeof(DocumentSummaryInformationOLEStream));	
	
	//setEntryPosition(mWriterMain, 1024); // saveas bogus
	//mWriterMain->WriteBytes(&WordDocumentOLEStream[0], sizeof(WordDocumentOLEStream));
	
	//mWriterTable->WriteBytes(&TableOLEStream[0], sizeof(TableOLEStream));	
	//mWriterMain->WriteBytes(&DebugDocumentStream[0], sizeof(DebugDocumentStream));
	
	//mWriterTable->WriteBytes(&DebugTableStream[0], sizeof(DebugTableStream));	
	
	entryWriter = mOleWriter->EntryWriter(mIndexCompObj);
	entryWriter->WriteBytes(&CompObjOLEStream[0], sizeof(CompObjOLEStream));	
	
}


// This routine fills in some streams that don't change,
// and also writes out a temp FIB for the main stream so
// that text can come next.
int32 TExportWORD::writeStaticStreams()
{
	TOLEEntryWriter *	entryWriter;

	// ROOT ENTRY - no need to write this, as it's done by the ole writer
	
	// SUMMARYINFO
	entryWriter = mOleWriter->EntryWriter(mIndexSumInfo);
	if (!entryWriter)
	{
		IFDEBUG(fprintf(stderr, "WORD writeStaticStreams: ERROR - no suminfo writer"));
		return B_ERROR;
	}
	entryWriter->WriteBytes(&SumInfoStreamData[0], BYTES_SUMINFO_1);	
	entryWriter->WriteBytes(mZeroBlock, BLOCKSIZE - BYTES_SUMINFO_1);
	for (long i = (BYTES_SUMINFO_TOTAL / BLOCKSIZE) - 1; i >= 0; i--)	
		entryWriter->WriteBytes(mZeroBlock, BLOCKSIZE);

	// DOCUMENTSUMMARYINFO
	entryWriter = mOleWriter->EntryWriter(mIndexDocSumInfo);
	if (!entryWriter)
	{
		IFDEBUG(fprintf(stderr, "WORD writeStaticStreams: ERROR - no docsuminfo writer"));
		return B_ERROR;
	}
	entryWriter->WriteBytes(&DocSumInfoStreamData[0], BYTES_DOCSUMINFO_1);	
	entryWriter->WriteBytes(mZeroBlock, BLOCKSIZE - BYTES_DOCSUMINFO_1);
	for (long i = (BYTES_DOCSUMINFO_TOTAL / BLOCKSIZE) - 1; i >= 0; i--)	
		entryWriter->WriteBytes(mZeroBlock, BLOCKSIZE);
	
	// COMPOBJ
	entryWriter = mOleWriter->EntryWriter(mIndexCompObj);
	if (!entryWriter)
	{
		IFDEBUG(fprintf(stderr, "WORD writeStaticStreams: ERROR - no compobj writer"));
		return B_ERROR;
	}
	entryWriter->WriteBytes(&CompObjStreamData[0], BYTES_COMPOBJ);	
	
	// MAIN - temp FIB (2 blocks)
	mWriterMain = mOleWriter->EntryWriter(mIndexMain);
	if (!mWriterMain)
	{
		IFDEBUG(fprintf(stderr, "WORD writeStaticStreams: ERROR - no main writer"));
		return B_ERROR;
	}
	mWriterMain->WriteBytes(&FibData[0], BYTES_FIB);	
	
	// 1TABLE - just get the writer
	mWriterTable = mOleWriter->EntryWriter(mIndexTable);
	if (!mWriterTable)
	{
		IFDEBUG(fprintf(stderr, "WORD writeStaticStreams: ERROR - no table writer"));
		return B_ERROR;
	}

    return B_OK;
}

int32 TExportWORD::initFIB()
{
	mFIBHeader.wIdent = 0xa5ec;
	mFIBHeader.nFib = 0xc1;
	mFIBHeader.nProduct = 0x47;
	mFIBHeader.lid = 0x409;
	mFIBHeader.pnNext = 0x0;
	mFIBHeader.bitField1 = 0x1200;
	mFIBHeader.nFibBack = 0xbf;
	mFIBHeader.lKey = 0x0;
	mFIBHeader.envr = 0x0;
	mFIBHeader.bitField2 = 0x10;
	mFIBHeader.chs = 0x0;
	mFIBHeader.chsTables = 0x0;
	mFIBHeader.fcMin = 0x400;
	mFIBHeader.fcMac = 0x405;
	
	mFIBShort[0] = 0x6a62;
	mFIBShort[1] = 0x6a62;
	mFIBShort[2] = 0xd98e;
	mFIBShort[3] = 0xd98e;
	mFIBShort[4] = 0x0;
	mFIBShort[5] = 0x0;
	mFIBShort[6] = 0x0;
	mFIBShort[7] = 0x0;
	mFIBShort[8] = 0x0;
	mFIBShort[9] = 0x0;
	mFIBShort[10] = 0x0;
	mFIBShort[11] = 0x0;
	mFIBShort[12] = 0x0;
	mFIBShort[13] = 0x409;
	
	mFIBLong[0] = 0xc1e;
	mFIBLong[1] = 0x1b3ec;
	mFIBLong[2] = 0x1b3ec;
	mFIBLong[3] = 0x5;
	mFIBLong[4] = 0x0;
	mFIBLong[5] = 0x0;
	mFIBLong[6] = 0x0;
	mFIBLong[7] = 0x0;
	mFIBLong[8] = 0x0;
	mFIBLong[9] = 0x0;
	mFIBLong[10] = 0x0;
	mFIBLong[11] = 0xfffff;
	mFIBLong[12] = 0x0;
	mFIBLong[13] = 0x0;
	mFIBLong[14] = 0xfffff;
	mFIBLong[15] = 0x0;
	mFIBLong[16] = 0x0;
	mFIBLong[17] = 0xfffff;
	mFIBLong[18] = 0x0;
	mFIBLong[19] = 0x0;
	mFIBLong[20] = 0x0;
	mFIBLong[21] = 0x0;
	
	mFIBPair[0].theLong = 0x0;
	mFIBPair[0].theULong = 0x92;
	mFIBPair[1].theLong = 0x0;
	mFIBPair[1].theULong = 0x92;
	mFIBPair[2].theLong = 0x92;
	mFIBPair[2].theULong = 0x0;
	mFIBPair[3].theLong = 0x92;
	mFIBPair[3].theULong = 0x0;
	mFIBPair[4].theLong = 0x92;
	mFIBPair[4].theULong = 0x0;
	mFIBPair[5].theLong = 0x92;
	mFIBPair[5].theULong = 0x0;
	mFIBPair[6].theLong = 0x92;
	mFIBPair[6].theULong = 0x14;
	mFIBPair[7].theLong = 0x0;
	mFIBPair[7].theULong = 0x0;
	mFIBPair[8].theLong = 0xa6;
	mFIBPair[8].theULong = 0x0;
	mFIBPair[9].theLong = 0xa6;
	mFIBPair[9].theULong = 0x0;
	mFIBPair[10].theLong = 0xa6;
	mFIBPair[10].theULong = 0x0;
	mFIBPair[11].theLong = 0xa6;
	mFIBPair[11].theULong = 0x0;
	mFIBPair[12].theLong = 0xa6;
	mFIBPair[12].theULong = 0xc;
	mFIBPair[13].theLong = 0xb2;
	mFIBPair[13].theULong = 0xc;
	mFIBPair[14].theLong = 0xa6;
	mFIBPair[14].theULong = 0x0;
	mFIBPair[15].theLong = 0x155;
	mFIBPair[15].theULong = 0xb6;
	mFIBPair[16].theLong = 0xca;
	mFIBPair[16].theULong = 0x0;
	mFIBPair[17].theLong = 0xca;
	mFIBPair[17].theULong = 0x0;
	mFIBPair[18].theLong = 0xca;
	mFIBPair[18].theULong = 0x0;
	mFIBPair[19].theLong = 0xca;
	mFIBPair[19].theULong = 0x0;
	mFIBPair[20].theLong = 0xca;
	mFIBPair[20].theULong = 0x0;
	mFIBPair[21].theLong = 0xca;
	mFIBPair[21].theULong = 0x0;
	mFIBPair[22].theLong = 0xca;
	mFIBPair[22].theULong = 0x0;
	mFIBPair[23].theLong = 0xca;
	mFIBPair[23].theULong = 0x0;
	mFIBPair[24].theLong = 0x11a;
	mFIBPair[24].theULong = 0x2;
	mFIBPair[25].theLong = 0x11c;
	mFIBPair[25].theULong = 0x0;
	mFIBPair[26].theLong = 0x11c;
	mFIBPair[26].theULong = 0x0;
	mFIBPair[27].theLong = 0x11c;
	mFIBPair[27].theULong = 0x0;
	mFIBPair[28].theLong = 0x11c;
	mFIBPair[28].theULong = 0x0;
	mFIBPair[29].theLong = 0x11c;
	mFIBPair[29].theULong = 0x0;
	mFIBPair[30].theLong = 0x11c;
	mFIBPair[30].theULong = 0x24;
	mFIBPair[31].theLong = 0x20b;
	mFIBPair[31].theULong = 0x1f4;
	mFIBPair[32].theLong = 0x3ff;		// StbfAssoc
//	mFIBPair[32].theULong = 0x56;
	mFIBPair[32].theULong = 0x00;
	mFIBPair[33].theLong = 0x140;
	mFIBPair[33].theULong = 0x15;
	mFIBPair[34].theLong = 0x0;
	mFIBPair[34].theULong = 0x0;
	mFIBPair[35].theLong = 0x0;
	mFIBPair[35].theULong = 0x0;
	mFIBPair[36].theLong = 0x92;
	mFIBPair[36].theULong = 0x0;
	mFIBPair[37].theLong = 0xca;
	mFIBPair[37].theULong = 0x0;
	mFIBPair[38].theLong = 0x0;
	mFIBPair[38].theULong = 0x0;
	mFIBPair[39].theLong = 0x0;
	mFIBPair[39].theULong = 0x0;
	mFIBPair[40].theLong = 0xca;
	mFIBPair[40].theULong = 0x0;
	mFIBPair[41].theLong = 0xca;
	mFIBPair[41].theULong = 0x0;
	mFIBPair[42].theLong = 0xca;
	mFIBPair[42].theULong = 0x0;
	mFIBPair[43].theLong = 0xca;
	mFIBPair[43].theULong = 0x0;
	mFIBPair[44].theLong = 0x140;
	mFIBPair[44].theULong = 0x0;
	mFIBPair[45].theLong = 0xd4;
	mFIBPair[45].theULong = 0x0;
	mFIBPair[46].theLong = 0x92;
	mFIBPair[46].theULong = 0x0;
	mFIBPair[47].theLong = 0x92;
	mFIBPair[47].theULong = 0x0;
	mFIBPair[48].theLong = 0xca;
	mFIBPair[48].theULong = 0x0;
	mFIBPair[49].theLong = 0x0;
	mFIBPair[49].theULong = 0x0;
	mFIBPair[50].theLong = 0xca;
	mFIBPair[50].theULong = 0x0;
	mFIBPair[51].theLong = 0xca;
	mFIBPair[51].theULong = 0x0;
	mFIBPair[52].theLong = 0xd4;
	mFIBPair[52].theULong = 0x0;
	mFIBPair[53].theLong = 0xd4;
	mFIBPair[53].theULong = 0x0;
	mFIBPair[54].theLong = 0xd4;
	mFIBPair[54].theULong = 0x0;
	mFIBPair[55].theLong = 0xca;
	mFIBPair[55].theULong = 0x0;
	mFIBPair[56].theLong = 0x92;
	mFIBPair[56].theULong = 0x0;
	mFIBPair[57].theLong = 0xca;
	mFIBPair[57].theULong = 0x0;
	mFIBPair[58].theLong = 0x92;
	mFIBPair[58].theULong = 0x0;
	mFIBPair[59].theLong = 0xca;
	mFIBPair[59].theULong = 0x0;
	mFIBPair[60].theLong = 0x11a;
	mFIBPair[60].theULong = 0x0;
	mFIBPair[61].theLong = 0x0;
	mFIBPair[61].theULong = 0x0;
	mFIBPair[62].theLong = 0x0;
	mFIBPair[62].theULong = 0x0;
	mFIBPair[63].theLong = 0xa6;
	mFIBPair[63].theULong = 0x0;
	mFIBPair[64].theLong = 0xa6;
	mFIBPair[64].theULong = 0x0;
	mFIBPair[65].theLong = 0x92;
	mFIBPair[65].theULong = 0x0;
	mFIBPair[66].theLong = 0x92;
	mFIBPair[66].theULong = 0x0;
	mFIBPair[67].theLong = 0x92;
	mFIBPair[67].theULong = 0x0;
	mFIBPair[68].theLong = 0x92;
	mFIBPair[68].theULong = 0x0;
	mFIBPair[69].theLong = 0xca;
	mFIBPair[69].theULong = 0x0;
	mFIBPair[70].theLong = 0x11a;
	mFIBPair[70].theULong = 0x0;
	mFIBPair[71].theLong = 0xd4;
	mFIBPair[71].theULong = 0x46;
	mFIBPair[72].theLong = 0xd4;
	mFIBPair[72].theULong = 0x0;
	mFIBPair[73].theLong = 0x0;
	mFIBPair[73].theULong = 0x0;
	mFIBPair[74].theLong = 0x11a;
	mFIBPair[74].theULong = 0x0;
	mFIBPair[75].theLong = 0x92;
	mFIBPair[75].theULong = 0x0;
	mFIBPair[76].theLong = 0x92;
	mFIBPair[76].theULong = 0x0;
	mFIBPair[77].theLong = 0x0;
	mFIBPair[77].theULong = 0x0;
	mFIBPair[78].theLong = 0x0;
	mFIBPair[78].theULong = 0x0;
	mFIBPair[79].theLong = 0x0;
	mFIBPair[79].theULong = 0x0;
	mFIBPair[80].theLong = 0x0;
	mFIBPair[80].theULong = 0x0;
	mFIBPair[81].theLong = 0x0;
	mFIBPair[81].theULong = 0x0;
	mFIBPair[82].theLong = 0x0;
	mFIBPair[82].theULong = 0x0;
	mFIBPair[83].theLong = 0x0;
	mFIBPair[83].theULong = 0x0;
	mFIBPair[84].theLong = 0x11a;
	mFIBPair[84].theULong = 0x0;
	mFIBPair[85].theLong = 0xca;
	mFIBPair[85].theULong = 0x0;
	mFIBPair[86].theLong = 0xbe;
	mFIBPair[86].theULong = 0xc;
	mFIBPair[87].theLong = 0x6e835da0;
	mFIBPair[87].theULong = 0x1be59dd;
	mFIBPair[88].theLong = 0xa6;
	mFIBPair[88].theULong = 0x0;
	mFIBPair[89].theLong = 0xa6;
	mFIBPair[89].theULong = 0x0;
	mFIBPair[90].theLong = 0xca;
	mFIBPair[90].theULong = 0xa;
	mFIBPair[91].theLong = 0x11a;
	mFIBPair[91].theULong = 0x0;
	mFIBPair[92].theLong = 0x0;
	mFIBPair[92].theULong = 0x0;

	// Force all pairs to zero. If we don't set the size we shouldn't be hard coding it!!!
	for (int32 x = 0; x <= 92; x++)
		mFIBPair[x].theULong = 0x0;
	
	//mFIBShort[wMagicCreated] = 0x6a63;
	//mFIBShort[wMagicRevised] = 0x6a63;
	
	mFIBHeader.fcMin = 0x400;
	mFIBHeader.fcMac = 0x400;
	mFIBLong[ccpText] = 0;
	return B_OK;

}

int32 TExportWORD::writeFIB()
{
	int i;
	setEntryPosition(mWriterMain, 0);
	
	mWriterMain->WriteShort(mFIBHeader.wIdent);	
	mWriterMain->WriteShort(mFIBHeader.nFib);	

	mWriterMain->WriteShort(mFIBHeader.nProduct);
	mWriterMain->WriteShort(mFIBHeader.lid);
	mWriterMain->WriteShort(mFIBHeader.pnNext);
	mWriterMain->WriteShort(mFIBHeader.bitField1);
	mWriterMain->WriteShort(mFIBHeader.nFibBack);
	mWriterMain->WriteLong(mFIBHeader.lKey);
	mWriterMain->WriteChar(mFIBHeader.envr);
	mWriterMain->WriteChar(mFIBHeader.bitField2);
	mWriterMain->WriteShort(mFIBHeader.chs);
	mWriterMain->WriteShort(mFIBHeader.chsTables);
	mWriterMain->WriteLong(mFIBHeader.fcMin);
	mWriterMain->WriteLong(mFIBHeader.fcMac);

	mWriterMain->WriteShort(NUM_FIB_SHORTS);
	for(i = 0; i < NUM_FIB_SHORTS; i++)
	{
		mWriterMain->WriteShort(mFIBShort[i]);
	}
	mWriterMain->WriteShort(NUM_FIB_LONGS);
	for(i = 0; i < NUM_FIB_LONGS; i++)
	{
		mWriterMain->WriteLong(mFIBLong[i]);
	}
	mWriterMain->WriteShort(NUM_FIB_PAIRS);
	for(i = 0; i < NUM_FIB_PAIRS; i++)
	{
		mWriterMain->WriteLong(mFIBPair[i].theLong);
		mWriterMain->WriteLong(mFIBPair[i].theULong);
	}
	
	return B_OK;

}

int32 TExportWORD::initDOP()
{
	memset(&mDOP.bitField1, 0, sizeof(DOP));
	
	mDOP.bitField1 = 0x22;
	mDOP.bitField2 = 0x4;
	mDOP.bitField3 = 0x831;
	mDOP.bitField4 = 0x1888;
	mDOP.bitField5 = 0x0;
	mDOP.dxaTab = 0x2d0;
	mDOP.wSpare = 0x0;
	mDOP.dxaHotZ = 0x168;
	mDOP.cConsecHypLim = 0x0;
	mDOP.wSpare2 = 0x0;
	mDOP.dttmCreated = 0x463282b3;
	mDOP.dttmRevised = 0x463282b3;
	mDOP.dttmLastPrint = 0x0;
	mDOP.nRevision = 0x1;
	mDOP.tmEdited = 0x0;
	mDOP.cWords = 0x0;
	mDOP.cCh = 0x4;
	mDOP.cPg = 0x1;
	mDOP.cParas = 0x1;
	mDOP.bitField6 = 0x4;
	mDOP.bitField7 = 0x1003;
	mDOP.cLines = 0x1;
	mDOP.cWordsFtnEdn = 0x0;
	mDOP.cChFtnEdn = 0x0;
	mDOP.cPgFtnEdn = 0x1;
	mDOP.cParasFtnEdn = 0x1;
	mDOP.cLinesFtnEdn = 0x1;
	mDOP.lKeyProtDoc = 0x0;
	mDOP.bitField8 = 0x22c1;
	
	mDOP.bitField9 = 0x0;
	
	mDOP.adt = 0x0;
	char doptypography[310] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	memcpy(mDOP.doptypography, doptypography, sizeof(doptypography));
	uchar dogrid[10] = {0xa5, 0x06, 0xc0, 0x07, 0xb4, 0x00, 0xb4, 0x00, 0x80, 0x00};
	memcpy(mDOP.dogrid, dogrid, sizeof(dogrid));
	mDOP.bitField10 = 0x3012;
	mDOP.bitField11 = 0x0;
	char asumyi[12] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	memcpy (mDOP.asumyi, asumyi, sizeof(asumyi));
	mDOP.cChWS = 0x4;
	mDOP.cChWSFtnEdn = 0x0;
	mDOP.grfDocEvents = 0x0;
	mDOP.bitField12 = 0x0;
	char spare[30] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	memcpy(mDOP.spare, spare, sizeof(spare));
	mDOP.reserved1 = 0x0;
	mDOP.reserved2 = 0x0;
	mDOP.cDBC = 0x0;
	mDOP.cDBCFtnEdn = 0x0;
	mDOP.reserved3 = 0x0;
	mDOP.nfcFtnRef = 0x0;
	mDOP.nfcEdnRef = 0x2;
	mDOP.hpsZoonFontPag = 0x0;
	mDOP.dywDispPag = 0x0;


	return B_OK;
}
int32 TExportWORD::writeDOP()
{
	mFIBPair[Dop].theLong = mWriterTable->GetStreamPos();

	mWriterTable->WriteBytes(StaticDop, sizeof(StaticDop));
/*

	mWriterTable->WriteShort(mDOP.bitField1);
	mWriterTable->WriteShort(mDOP.bitField2);
	mWriterTable->WriteShort(mDOP.bitField3);
	mWriterTable->WriteShort(mDOP.bitField4);
	mWriterTable->WriteShort(mDOP.bitField5);
	mWriterTable->WriteShort(mDOP.dxaTab);
	mWriterTable->WriteShort(mDOP.wSpare);
	mWriterTable->WriteShort(mDOP.dxaHotZ);
	mWriterTable->WriteShort(mDOP.cConsecHypLim);
	mWriterTable->WriteShort(mDOP.wSpare2);
	
	mWriterTable->WriteLong(mDOP.dttmCreated);
	mWriterTable->WriteLong(mDOP.dttmRevised);
	mWriterTable->WriteLong(mDOP.dttmLastPrint);
	
	mWriterTable->WriteShort(mDOP.nRevision);
	
	mWriterTable->WriteLong(mDOP.tmEdited);
	mWriterTable->WriteLong(mDOP.cWords);
	mWriterTable->WriteLong(mDOP.cCh);
	
	mWriterTable->WriteShort(mDOP.cPg);
	
	mWriterTable->WriteLong(mDOP.cParas);
	
	mWriterTable->WriteShort(mDOP.bitField6);
	mWriterTable->WriteShort(mDOP.bitField7);
	
	mWriterTable->WriteLong(mDOP.cLines);
	mWriterTable->WriteLong(mDOP.cWordsFtnEdn);
	mWriterTable->WriteLong(mDOP.cChFtnEdn);
	
	mWriterTable->WriteShort(mDOP.cPgFtnEdn);
	
	mWriterTable->WriteLong(mDOP.cParasFtnEdn);
	mWriterTable->WriteLong(mDOP.cLinesFtnEdn);
	mWriterTable->WriteLong(mDOP.lKeyProtDoc);
	
	mWriterTable->WriteShort(mDOP.bitField8);
	
	mWriterTable->WriteLong(mDOP.bitField9);

	mWriterTable->WriteShort(mDOP.adt);
	
	mWriterTable->WriteBytes(&mDOP.doptypography[0], 310);
	mWriterTable->WriteBytes(&mDOP.dogrid[0], 10);

	mWriterTable->WriteShort(mDOP.bitField10);
	mWriterTable->WriteShort(mDOP.bitField11);
	
	mWriterTable->WriteBytes(&mDOP.asumyi[0], 12);

	mWriterTable->WriteLong(mDOP.cChWS);
	mWriterTable->WriteLong(mDOP.cChWSFtnEdn);
	mWriterTable->WriteLong(mDOP.grfDocEvents);
	mWriterTable->WriteLong(mDOP.bitField12);
	
	mWriterTable->WriteBytes(&mDOP.spare[0], 30);

	mWriterTable->WriteLong(mDOP.reserved1);
	mWriterTable->WriteLong(mDOP.reserved2);
	mWriterTable->WriteLong(mDOP.cDBC);
	mWriterTable->WriteLong(mDOP.cDBCFtnEdn);
	mWriterTable->WriteLong(mDOP.reserved3);

	mWriterTable->WriteShort(mDOP.nfcFtnRef);
	mWriterTable->WriteShort(mDOP.nfcEdnRef);
	mWriterTable->WriteShort(mDOP.hpsZoonFontPag);
	mWriterTable->WriteShort(mDOP.dywDispPag);

*/
	
	mFIBPair[Dop].theULong = mWriterTable->GetStreamPos() - mFIBPair[Dop].theLong;

	return B_OK;
}


int32 TExportWORD::processText(const char* text, int32 text_length, long& char_count)
{
	int32 			dataSize = text_length;
	const char* 	dataPtr = text;
		
	// Change new lines to carriage returns.
	for (int i = 0; i < mBufferSize; i++)
		if (mBuffer[i] == 10)
			mBuffer[i] = 13;
	
	
	convertToUnicodeBuffer(dataPtr, dataSize);

	mWriterMain->WriteBytes(&mBuffer[0], mBufferSize);

	mFIBHeader.fcMac += mBufferSize; 
	char_count += mBufferSize / 2;
	
    return B_OK;
}

int32 TExportWORD::processPart(const TTranslatorPart_WP* part, int32 &char_count)
{
	TTextIterator_WP	i(part);
	uchar 				runBuffer[TEXTRUN_BUFFER_SIZE + 1];
	int32 				runLength;
	int32				runningByteCount = 0;
	int32				runByteLength = 0;
	int32				paraStart = 0;
	bool				wasText = false;
	
	while (runLength = i.NextTextRun(runBuffer, TEXTRUN_BUFFER_SIZE), runLength)
	{
		bool special = false;
		wasText = true;
		runByteLength = GetStringCharCount((char*) runBuffer, runLength);

		runByteLength *= 2;

		runBuffer[runLength] = 0;
		IFDEBUG(fprintf(stderr, "TextRun{%d}: %s\n", runLength, runBuffer));
		

		const TSpecialCharacter* specialChar;
		specialChar = i.SpecialCharacter();
		if (specialChar && specialChar->Kind() == kSCBreak)
		{
			runLength = 1;
			processText("\f", runLength, char_count);
		}
		/*else if(specialChar && specialChar->Kind() == kSCFootnote)
		{
			char str[] = {0x02, 0x00};
			const TSpecialCharacter_Footnote* footnote;
			footnote = dynamic_cast<const TSpecialCharacter_Footnote*>(specialChar);
			if (footnote && part == mMainPartPtr)
			{
				special = true;
				runLength = 1;
				if (footnote->IsEndnote())
					mEndnoteTbl->AddFootnote(char_count, footnote->ContentPart(), N_ENDNOTE);
				else
					mFootnoteTbl->AddFootnote(char_count, footnote->ContentPart(), N_FOOTNOTE);
				processText(str, runLength, char_count);
			}
			else
				processText((char*) runBuffer, runLength, char_count);
		}*/
		else if(specialChar &&  specialChar->Text()) // it's a special char we don't know how to handle,
		{											// but it has replacement text
			runLength = strlen(specialChar->Text());
			runByteLength = GetStringCharCount(specialChar->Text(), runLength) * 2;
			
			processText(specialChar->Text(), runLength, char_count);
		}
		else // it's the usual case of text coming in
			processText((char*) runBuffer, runLength, char_count);


		if (i.IsParStart())
			paraStart = runningByteCount;
		
		if (i.IsParEnd())
		{
			mFKP_PAPX->addRun((runningByteCount + runByteLength) - paraStart, i.ParagraphStylePtr(), mFontTbl, mStyleTbl);
			if (part == mPartPtr)
				mLastParaStyle = i.ParagraphStylePtr();
		}
		
		mFKP_CHPX->addRun(runByteLength, i.CharacterStylePtr(), mFontTbl, mStyleTbl, special);
		if (part == mPartPtr)
			mLastCharStyle = i.CharacterStylePtr();

		runningByteCount += runByteLength;
	}
	
	processText("\n", 1, char_count);
	
	/*mWriterMain->WriteBytes("\l", 1);
	
	mFIBHeader.fcMac++; 
	char_count++;*/
	
	if (wasText)
	{
		mFKP_CHPX->extendLastRun(2);
		mFKP_PAPX->extendLastRun(2);
	}
	else
	{
		mFKP_CHPX->addRun(2, mBlankStyle, mFontTbl, mStyleTbl);
		mFKP_PAPX->addRun(2, mBlankStyle, mFontTbl, mStyleTbl);
		if (part == mPartPtr)
		{
			mLastCharStyle = mBlankStyle;
			mLastParaStyle = mBlankStyle;
		}

	}
	
	return B_NO_ERROR;
}

int32 TExportWORD::writePieceTable()
{
	mFIBPair[Clx].theLong = mWriterTable->GetStreamPos();
	mFIBPair[Clx].theULong = 21;

	// write clxt (type of the block that follows: 2 = plcfpcd)
	mWriterTable->WriteChar(0x02);
	
	// write count of the bytes in the piece table that follows. (2*sizeof(FC) + 1*sizeof(PCD)) - Our table has only 1 entry.
	mWriterTable->WriteLong(0x10);

	// determine number of characters being saved to the file.	
	int32 numChars = mFIBHeader.fcMac - mFIBHeader.fcMin;
	#ifdef UNICODE_OUT
	numChars /= 2;
	#endif

	// Write starting and ending character positions for our single entry.
	mWriterTable->WriteLong(0); // CP of the first char is 0
	mWriterTable->WriteLong(numChars);

	// Write out our PCD. Flags - unknown value here.	
	mWriterTable->WriteShort(0x0030);
	long fcStart = 0x400;
#ifndef UNICODE_OUT
	fcStart *= 2;
	fcStart |= 0x40000000;
#endif	
	mWriterTable->WriteLong(fcStart);
	mWriterTable->WriteShort(0x00);
    return B_OK;
}

int32 TExportWORD::writeSED()
{
	mFIBPair[Plcfsed].theLong = mWriterTable->GetStreamPos();
	mFIBPair[Plcfsed].theULong = 20;
	
	mWriterTable->WriteLong(0); // CP of the first char is 0
#ifdef UNICODE_OUT
	mWriterTable->WriteLong((mFIBHeader.fcMac - mFIBHeader.fcMin) / 2);
#else
	mWriterTable->WriteLong(mFIBHeader.fcMac - mFIBHeader.fcMin);
#endif // -BOGUS this is not what I am expecting an actual word file to look like, but it should still work
	
	mWriterTable->WriteShort(0x04); // used internally by word
	mWriterTable->WriteLong(0xffffffff);
	mWriterTable->WriteShort(0x00); // used internally by word

	mWriterTable->WriteLong(0xffffffff);
	
	
	/*long SEPXlocation = 512 * (((mWriterMain->GetStreamPos() - 1) / 512) + 1);
	
	printf("\nmWriterMain->GetStreamPos() = %d\n", mWriterMain->GetStreamPos());
	printf("\nSEPXlocation = %d\n", SEPXlocation);
	mWriterMain->SetStreamPos(SEPXlocation);
	
	char theSEPX[] =
	{ 0x1c, 0x00, 0x1f, 0xb0, 0xd0, 0x2f, 0x20, 0xb0, 0xe0, 0x3d, 0x21, 0xb0, 0x08, 0x07, 0x22, 0xb0,
      0x08, 0x07, 0x23, 0x90, 0xa0, 0x05, 0x24, 0x90, 0xa0, 0x05, 0x25, 0xb0};

	mWriterMain->SetStreamPos(mWriterMain->GetStreamPos());
	
	mWriterMain->WriteBytes(theSEPX, sizeof(theSEPX));
	setEntryPosition(mWriterMain, SEPXlocation + 512);

	mWriterTable->SetStreamPos(mWriterTable->GetStreamPos());
	
	mWriterTable->WriteLong(0); // CP of the first char is 0
	mWriterTable->WriteLong(mFIBHeader.fcMac - mFIBHeader.fcMin);
	
	mWriterTable->WriteShort(0x04); // undefined reserved value
	mWriterTable->WriteLong(SEPXlocation);
	mWriterTable->WriteShort(0x00); // undefined reserved value

	mWriterTable->WriteLong(0xffffffff);*/
	
    return B_OK;
}

int32 TExportWORD::writeLVC()
{
	int32 fkp_page = ((mWriterMain->GetStreamPos() - 1) / 512) + 1;
	
	setEntryPosition(mWriterMain, fkp_page * 512);
	mWriterMain->WriteLong(mFIBHeader.fcMin);
	mWriterMain->WriteLong(mFIBHeader.fcMac); // this is not what I am expecting an actual word
												// file to look like, but it should still work
	setEntryPosition(mWriterMain, (fkp_page * 512) + 511);
	mWriterMain->WriteChar(1);
	
	mFIBPair[PlcfbteLvc].theLong = mWriterTable->GetStreamPos();
	mFIBPair[PlcfbteLvc].theULong = 12;
	mFIBLong[pnLvcFirst] = fkp_page; // word doesn't write these out, why shoould I? because it makes me happy
	mFIBLong[cpnBteLvc] = 1;

	mWriterTable->WriteLong(0);
#ifdef UNICODE_OUT
	mWriterTable->WriteLong((mFIBHeader.fcMac - mFIBHeader.fcMin) / 2);
#else
	mWriterTable->WriteLong(mFIBHeader.fcMac - mFIBHeader.fcMin);
#endif // -BOGUS this is not what I am expecting an actual word file to look like, but it should still work

	mWriterTable->WriteLong(fkp_page);

    return B_OK;
}

int32 TExportWORD::writeNotes()
{
	char str[] = {0x02, 0x20};
	int32 subdocument_size = 0;
	
	
	if (mFootnoteTbl->Count())
	{	
		for (int i = 0; i < mFootnoteTbl->Count(); i++)
		{
			int32 note_size = 0;
			processText(str, 2, note_size);
			processPart((TTranslatorPart_WP*) mFootnoteTbl->GetPart(i), note_size);
			subdocument_size += note_size;
			mFootnoteTbl->AddNoteEnd(subdocument_size);
		}
		processText("\n\n", 2, subdocument_size);
		
		mFIBLong[ccpFtn] = subdocument_size; // is this the right value?
	
		mFIBPair[PlcffndRef].theLong = mWriterTable->GetStreamPos();
		mFIBPair[PlcffndRef].theULong = mFootnoteTbl->Count() * 6 + 4;
		
		for (int i = 0; i < mFootnoteTbl->Count(); i++)
			mWriterTable->WriteLong(mFootnoteTbl->GetPosition(i));
		mWriterTable->WriteLong(mFIBLong[ccpText] + mFIBLong[ccpFtn]);
		for (int i = 0; i < mFootnoteTbl->Count(); i++)
			mWriterTable->WriteShort(1);
		
		mFIBPair[PlcffndTxt].theLong = mWriterTable->GetStreamPos();
		mFIBPair[PlcffndTxt].theULong = (mFootnoteTbl->Count() + 2) * 4;
		
		mWriterTable->WriteLong(0);
		for (int i = 0; i < mFootnoteTbl->Count(); i++)
			mWriterTable->WriteLong(mFootnoteTbl->GetEnd(i));
		mWriterTable->WriteLong(mFootnoteTbl->GetEnd(mFootnoteTbl->Count() - 1) + 3);

	}

	if (mEndnoteTbl->Count())
	{	
	subdocument_size = 0;
		for (int i = 0; i < mEndnoteTbl->Count(); i++)
		{
			int32 note_size = 0;
			processText(str, 2, note_size);
			processPart((TTranslatorPart_WP*) mEndnoteTbl->GetPart(i), note_size);
			subdocument_size += note_size;
			mEndnoteTbl->AddNoteEnd(subdocument_size);
		}
		mFIBLong[ccpEdn] = subdocument_size;

		mFIBPair[PlcfednRef].theLong = mWriterTable->GetStreamPos();
		mFIBPair[PlcfednRef].theULong = mEndnoteTbl->Count() * 4;
		
		for (int i = 0; i < mEndnoteTbl->Count(); i++)
			mWriterTable->WriteLong(mEndnoteTbl->GetPosition(i));
		
		mFIBPair[PlcfednTxt].theLong = mWriterTable->GetStreamPos();
		mFIBPair[PlcfednTxt].theULong = (mEndnoteTbl->Count() + 1) * 4;
		
		mWriterTable->WriteLong(0);
		for (int i = 0; i < mEndnoteTbl->Count(); i++)
			mWriterTable->WriteLong(mEndnoteTbl->GetEnd(i));
	}

	
	return B_OK;
}


int32 TExportWORD::writeHeaders()
{
	TTranslatorStyle emptyStyle;		

	mFIBPair[Plcfhdd].theLong = mWriterTable->GetStreamPos();
	
	if (mHeaderPartPtr == 0 && mFooterPartPtr == 0) // if there are no headers or footer, we don't need to do anything
	{
		mFIBPair[Plcfhdd].theULong = 0;
	    return B_OK;
	}
	
	mFIBPair[Plcfhdd].theULong = 14 * 4;
	
	//int32 the_value = mFIBPair[Plcfhdd].theLong;
	IFDEBUG(fprintf(stderr, "%d", mFIBPair[Plcfhdd].theLong));
	
	int32 hdd_static[] =
			{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
	
	for (int i = 0; i < (int) (sizeof(hdd_static) / sizeof(int32)); i++)
		mWriterTable->WriteLong(hdd_static[i]);
	
	int32 headerEnd = 0, footerEnd = 0;
	
	if (mHeaderPartPtr != 0)
	{
		processPart(mHeaderPartPtr, mFIBLong[ccpHdr]);
		processText("\x0d", 1, mFIBLong[ccpHdr]); // one last CR
		mFKP_CHPX->addRun(2, &emptyStyle, mFontTbl, mStyleTbl); // style for the end of header 0x0d
		mFKP_PAPX->addRun(2, &emptyStyle, mFontTbl, mStyleTbl); // style for the end of header 0x0d
	}
	headerEnd = mFIBLong[ccpHdr];
	
	if (mFooterPartPtr != 0)
	{
		processPart(mFooterPartPtr, mFIBLong[ccpHdr]);
		processText("\x0d", 1, mFIBLong[ccpHdr]); // one last CR
		mFKP_CHPX->addRun(2, &emptyStyle, mFontTbl, mStyleTbl); // style for the end of header 0x0d
		mFKP_PAPX->addRun(2, &emptyStyle, mFontTbl, mStyleTbl); // style for the end of header 0x0d
	}	
	footerEnd = mFIBLong[ccpHdr];
	
	processText("\x0d", 1, mFIBLong[ccpHdr]);
	mFKP_CHPX->addRun(2, &emptyStyle, mFontTbl, mStyleTbl); // style for the end of all header 0x0d
	mFKP_PAPX->addRun(2, &emptyStyle, mFontTbl, mStyleTbl); // style for the end of all header 0x0d
	
	mWriterTable->WriteLong(headerEnd);
	mWriterTable->WriteLong(headerEnd);
	mWriterTable->WriteLong(footerEnd);
	mWriterTable->WriteLong(footerEnd);
	mWriterTable->WriteLong(footerEnd);
	mWriterTable->WriteLong(footerEnd + 3);
	
	long the_long;
	processText("\x0d", 1, the_long); // Word uses the paragraph style of this char at the para style of the last paragraph
	mFKP_CHPX->addRun(2, mLastCharStyle, mFontTbl, mStyleTbl); 
	//mFKP_PAPX->addRun(2, &emptyStyle, mFontTbl, mStyleTbl); 
	
	mFKP_PAPX->addRun(2, mLastParaStyle, mFontTbl, mStyleTbl); 
		
    return B_OK;
}

//int32 TExportWORD::finishWordDocument()
//{
//	// pad the text out to an even block boundary
//	int32 padBytes = mBytesTextWritten % BLOCKSIZE;
//	IFDEBUG(fprintf(stderr, "WORD finishWordDocument: %d pad after text\n", BLOCKSIZE - padBytes));
//	if (padBytes)
//		mWriterMain->WriteBytes(mZeroBlock, BLOCKSIZE - padBytes);	
//	
//	// fake up the rest of the main stream
//	char fakeFKP[6] = {0x00, 0x04, 0x00, 0x00, 0x05, 0x04};
//	char fakeFKP2[3] = {0x00, 0x00, 0xfd};
//	char fakeFKP3[5] = {0x01, 0x00, 0x00, 0x00, 0x01};
//
//	// CHPX FKP
//	mWriterMain->WriteBytes(&fakeFKP[0], 6);	
//	mWriterMain->WriteBytes(mZeroBlock, BLOCKSIZE - 7);	
//	mWriterMain->WriteBytes(&fakeFKP3[0], 1);	
//
//	// PAPX FKP
//	mWriterMain->WriteBytes(&fakeFKP[0], 6);	
//	mWriterMain->WriteBytes(&fakeFKP2[0], 3);	
//	mWriterMain->WriteBytes(mZeroBlock, BLOCKSIZE - 14);	
//	mWriterMain->WriteBytes(&fakeFKP3[0], 5);	
//
//	// LVC FKP
//	mWriterMain->WriteBytes(&fakeFKP[0], 6);	
//	mWriterMain->WriteBytes(mZeroBlock, BLOCKSIZE - 7);	
//	mWriterMain->WriteBytes(&fakeFKP3[0], 1);		
//
//	// SEPX
//	char fakeSEPX[28] = {0x1c, 0x00, 0x1f, 0xb0, 0xd0, 0x2f, 0x20, 0xb0, 0xe0, 0x3d, 0x21, 0xb0, 0x08, 0x07, 0x22, 0xb0,
//						0x08, 0x07, 0x23, 0x90, 0xa0, 0x05, 0x24, 0x90, 0xa0, 0x05, 0x25, 0xb0};	
//	mWriterMain->WriteBytes(&fakeSEPX[0], 28);	
//	mWriterMain->WriteBytes(mZeroBlock, BLOCKSIZE - 28);	
//
//	// 1TABLE
//	mWriterTable->WriteBytes(&TableStshData[0], BYTES_TABLE_STSH);	
//	mWriterTable->WriteBytes(&Table1Data[0], BYTES_TABLE_1);
//
//	// piece table - BOGUS replace this with writing a real piece table so that we can identify
//	// the unicode text and the proper length
//	char fakePiece[21] = {0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
//						0x08, 0x00, 0x40, 0x00, 0x00};	
//	mWriterTable->WriteBytes(&fakePiece[0], 21);	
//
//	mWriterTable->WriteBytes(&Table2Data[0], BYTES_TABLE_2);	
//	mWriterTable->WriteBytes(mZeroBlock, BYTES_TABLE_ZERO_PAD2);	
//	mWriterTable->WriteBytes(&Table3Data[0], BYTES_TABLE_3);	
//
//    return B_OK;
//}


// copy the dataPtr into our buffer and make it Unicode
int32 TExportWORD::convertToUnicodeBuffer(const char *dataPtr, int32 dataSize)
{
	// Make sure our buffer is big enough
	if ((dataSize * 2) > mBufferMaxSize)
	{
		// need to make the buffer bigger
		delete [] mBuffer;
		mBufferMaxSize = (dataSize * 2);
		mBuffer = new char[mBufferMaxSize];
		mBufferSize = 0;
		if (!mBuffer)
			return B_NO_MEMORY;
	}
				
	// convert dataPtr from utf8 to Unicode
	int32	srcBytes = dataSize;
	mBufferSize = mBufferMaxSize;
	int32 state = 0;
	
	convert_from_utf8(B_UNICODE_CONVERSION, (char *)dataPtr, &srcBytes, mBuffer, &mBufferSize, &state, '?');
	
	for (int i = 0; i < mBufferSize / 2; i++)
	{
		((short*) mBuffer)[i] = B_SWAP_INT16(((short*) mBuffer)[i]);

		if (B_LENDIAN_TO_HOST_INT16(((short*) mBuffer)[i]) == 10)
			((short*) mBuffer)[i] = B_HOST_TO_LENDIAN_INT16(13);
	}	
	
    return B_OK;
}

int32 TExportWORD::convertToMSWindowsBuffer(const char *dataPtr, int32 dataSize)
{
	// Make sure our buffer is big enough
	if ((dataSize * 2) > mBufferMaxSize) // -bogus I don't think we need twice the size, but then again I
	{									// don't know anything about MS Windows encoding
		// need to make the buffer bigger
		delete [] mBuffer;
		mBufferMaxSize = (dataSize * 2);
		mBuffer = new char[mBufferMaxSize];
		mBufferSize = 0;
		if (!mBuffer)
			return B_NO_MEMORY;
	}
				
	// convert dataPtr from utf8 to MSWindows
	int32 srcBytes = dataSize;
	mBufferSize = mBufferMaxSize;
	int32 state = 0;
	
	convert_from_utf8(B_MS_WINDOWS_CONVERSION, (char *)dataPtr, &srcBytes, mBuffer, &mBufferSize, &state, '?');
		
    return B_OK;
}



void TFootnoteTblWord::AddFootnote(int32 position, const TTranslatorPart* part, int type)
{
	mPositionList.AddItem((void*) position);
	mPartList.AddItem((void*) part);
	mTypeList.AddItem((void*) type);
}



char CompObjStreamData[] = {
	0x01, 0x00, 0xfe, 0xff, 0x03, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x06, 0x09, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x18, 0x00, 0x00, 0x00,
	0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x44,
	0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x4d, 0x53, 0x57, 0x6f,
	0x72, 0x64, 0x44, 0x6f, 0x63, 0x00, 0x10, 0x00, 0x00, 0x00, 0x57, 0x6f, 0x72, 0x64, 0x2e, 0x44,
	0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x38, 0x00, 0xf4, 0x39, 0xb2, 0x71, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char SumInfoStreamData[] = {
	0xfe, 0xff, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe0, 0x85, 0x9f, 0xf2,
	0xf9, 0x4f, 0x68, 0x10, 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9, 0x30, 0x00, 0x00, 0x00,
	0x60, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0xac, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,
	0x07, 0x00, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00,
	0x09, 0x00, 0x00, 0x00, 0xf4, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x0a, 0x00, 0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x28, 0x01, 0x00, 0x00,
	0x0d, 0x00, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00,
	0x0f, 0x00, 0x00, 0x00, 0x48, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x50, 0x01, 0x00, 0x00,
	0x13, 0x00, 0x00, 0x00, 0x58, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xe4, 0x04, 0x00, 0x00,
	0x1e, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x66, 0x00,
	0x1e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x65, 0x73, 0x74, 0x1e, 0x00, 0x00, 0x00,
	0x0a, 0x00, 0x00, 0x00, 0x45, 0x72, 0x6e, 0x69, 0x65, 0x20, 0x50, 0x61, 0x6e, 0x00, 0x20, 0x00,
	0x1e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x6f, 0x62, 0x20, 0x1e, 0x00, 0x00, 0x00,
	0x0b, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x2e, 0x64, 0x6f, 0x74, 0x00, 0x00,
	0x1e, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x45, 0x72, 0x6e, 0x69, 0x65, 0x20, 0x50, 0x61,
	0x6e, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x31, 0x00, 0x62, 0x20,
	0x1e, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66,
	0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x38, 0x2e, 0x30, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x42, 0x5d, 0x4b,
	0xdd, 0x59, 0xbe, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x42, 0x5d, 0x4b, 0xdd, 0x59, 0xbe, 0x01,
	0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char DocSumInfoStreamData[] = {
	0xfe, 0xff, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0xd5, 0xcd, 0xd5,
	0x9c, 0x2e, 0x1b, 0x10, 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae, 0x44, 0x00, 0x00, 0x00,
	0x05, 0xd5, 0xcd, 0xd5, 0x9c, 0x2e, 0x1b, 0x10, 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae,
	0x30, 0x01, 0x00, 0x00, 0xec, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x68, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
	0x7c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
	0x8c, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
	0x9c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
	0xac, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0xb4, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
	0xbc, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0xcd, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0xe4, 0x04, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x74, 0x65,
	0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xb3, 0x0d, 0x08, 0x00,
	0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1e, 0x10, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x74, 0x65, 0x73, 0x74,
	0x00, 0x0c, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
	0x00, 0x54, 0x69, 0x74, 0x6c, 0x65, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x98, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x5f, 0x50, 0x49, 0x44,
	0x5f, 0x47, 0x55, 0x49, 0x44, 0x00, 0x02, 0x00, 0x00, 0x00, 0xe4, 0x04, 0x00, 0x00, 0x41, 0x00,
	0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x7b, 0x00, 0x39, 0x00, 0x45, 0x00, 0x30, 0x00, 0x32, 0x00,
	0x41, 0x00, 0x36, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2d, 0x00, 0x43, 0x00, 0x35, 0x00, 0x38, 0x00,
	0x44, 0x00, 0x2d, 0x00, 0x31, 0x00, 0x31, 0x00, 0x44, 0x00, 0x32, 0x00, 0x2d, 0x00, 0x38, 0x00,
	0x42, 0x00, 0x36, 0x00, 0x34, 0x00, 0x2d, 0x00, 0x34, 0x00, 0x34, 0x00, 0x34, 0x00, 0x35, 0x00,
	0x35, 0x00, 0x33, 0x00, 0x35, 0x00, 0x34, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00,
	0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char FibData[] = {
	0xec, 0xa5, 0xc1, 0x00, 0x47, 0x00, 0x09, 0x04, 0x00, 0x00, 0x00, 0x12, 0xbf, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x05, 0x04, 0x00, 0x00,
	0x0e, 0x00, 0x62, 0x6a, 0x62, 0x6a, 0x8e, 0xd9, 0x8e, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x04, 0x16, 0x00,
	0x1e, 0x0c, 0x00, 0x00, 0xec, 0xb3, 0x01, 0x00, 0xec, 0xb3, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x14, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x0c, 0x00,
	0x00, 0x00, 0xb2, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x55, 0x01, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x24, 0x00,
	0x00, 0x00, 0x0b, 0x02, 0x00, 0x00, 0xf4, 0x01, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x56, 0x00,
	0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x0c, 0x00,
	0x00, 0x00, 0xa0, 0x5d, 0x83, 0x6e, 0xdd, 0x59, 0xbe, 0x01, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xca, 0x00, 0x00, 0x00, 0x0a, 0x00,
	0x00, 0x00, 0x1a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char TableStshData[] = {
	0x12, 0x00, 0x0f, 0x00, 0x0a, 0x00, 0x01, 0x00, 0x5b, 0x00, 0x0f, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x40, 0xf1, 0xff, 0x02, 0x00, 0x24, 0x00, 0x00, 0x00,
	0x06, 0x00, 0x4e, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x6d, 0x48, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x41, 0x40,
	0xf2, 0xff, 0xa1, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x16, 0x00, 0x44, 0x00, 0x65, 0x00, 0x66, 0x00,
	0x61, 0x00, 0x75, 0x00, 0x6c, 0x00, 0x74, 0x00, 0x20, 0x00, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00,
	0x61, 0x00, 0x67, 0x00, 0x72, 0x00, 0x61, 0x00, 0x70, 0x00, 0x68, 0x00, 0x20, 0x00, 0x46, 0x00,
	0x6f, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00
};

char Table1Data[] = {
				0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x0c, 0x00, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x04, 0x00, 0x00, 0x05, 0x04, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x05, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x05, 0x04, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
	0x00, 0x00, 0x04, 0x00, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x42, 0x00, 0x6f, 0x00,
	0x62, 0x00, 0x20, 0x00, 0x48, 0x00, 0x65, 0x00, 0x61, 0x00, 0x72, 0x00, 0x6e, 0x00, 0x15, 0x00,
	0x43, 0x00, 0x3a, 0x00, 0x5c, 0x00, 0x63, 0x00, 0x61, 0x00, 0x72, 0x00, 0x6c, 0x00, 0x5c, 0x00,
	0x77, 0x00, 0x39, 0x00, 0x37, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6d, 0x00, 0x70, 0x00, 0x6c, 0x00,
	0x65, 0x00, 0x2e, 0x00, 0x64, 0x00, 0x6f, 0x00, 0x63, 0x00, 0xff, 0x40, 0x00, 0x80, 0x01, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x78, 0xa6, 0x85, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char Table2Data[] = {
								  0x03, 0x00, 0x00, 0x00, 0x47, 0x16, 0x90, 0x01, 0x00, 0x00, 0x02,
	0x02, 0x06, 0x03, 0x05, 0x04, 0x05, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x54, 0x00, 0x69, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x4e, 0x00, 0x65,
	0x00, 0x77, 0x00, 0x20, 0x00, 0x52, 0x00, 0x6f, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x6e, 0x00, 0x00,
	0x00, 0x35, 0x16, 0x90, 0x01, 0x02, 0x00, 0x05, 0x05, 0x01, 0x02, 0x01, 0x07, 0x06, 0x02, 0x05,
	0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x79, 0x00, 0x6d, 0x00, 0x62,
	0x00, 0x6f, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x33, 0x26, 0x90, 0x01, 0x00, 0x00, 0x02, 0x0b, 0x06,
	0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41,
	0x00, 0x72, 0x00, 0x69, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x00, 0x00, 0x22, 0x00, 0x04, 0x00, 0x31,
	0x08, 0x88, 0x18, 0x00, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x68, 0x01, 0x00, 0x00, 0x00, 0x00, 0xb3,
	0x82, 0x32, 0x46, 0xb3, 0x82, 0x32, 0x46, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x03, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x22, 0x00
};

char Table3Data[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa5, 0x06, 0xc0, 0x07, 0xb4,
	0x00, 0xb4, 0x00, 0x80, 0x00, 0x12, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73,
	0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x42, 0x00, 0x6f, 0x00, 0x62,
	0x00, 0x20, 0x00, 0x48, 0x00, 0x65, 0x00, 0x61, 0x00, 0x72, 0x00, 0x6e, 0x00, 0x09, 0x00, 0x42,
	0x00, 0x6f, 0x00, 0x62, 0x00, 0x20, 0x00, 0x48, 0x00, 0x65, 0x00, 0x61, 0x00, 0x72, 0x00, 0x6e              
};

// $Header: /usr/local/cvsroot/8ball/Datatypes/WORD/ExportWORD.cpp,v 1.47 2000/02/17 03:29:46 joel Exp $
