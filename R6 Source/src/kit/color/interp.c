/* File :interp.c		@(#)interp.c	13.9 10/30/95 */

/***************************************************************
  PROPRIETARY NOTICE: The software information contained
  herein is the sole property of Eastman Kodak Company and is
  provided to Eastman Kodak Company users under license for use on
  their designated equipment only.  Reproduction of this matter in
  whole or in part is forbidden without the express written
  consent of Eastman Kodak Company.

  COPYRIGHT (c) 1991-1995 Eastman Kodak Company.
  As an unpublished work pursuant to Title 17 of the United
  States Code.  All rights reserved.
****************************************************************
*/
/*
 * array interpolation generator :
 *
 * DIM==1 yields linear interpolator (1 in, 1 out)
 * DIM==2 yields bi-linear interpolator (2 in, 1 out)
 * DIM==3 yields tri-linear interpolator (3 in, 1 out) [default]
 *
 * BITS==8 yields interpolator of 8-bit data
 * BITS==12 yields interpolator of 12-bit data
 * BITS==0 yields a special 12-bit interpolator.  This version is
 *	   primarily for table composition and assumes that the
 *	   supplied input tables are for 12-bit input. [default]
 *
 * ORDER==0 yields nearest neighbor interpolator
 * ORDER==1 yields linear interpolator [default]
 * ORDER==2 yields cubic interpolator
 *
 * if neither DIM, BITS, nor ORDER is defined, then all 18 varieties of
 * fut_interp_xxx will be generated by setting these symbols and including
 * this file.  In this case, we also generate the dispatch function,
 * fut_interp_fun(), which returns the address of the appropriate
 * function at run-time given (bits,order,dim).
 */

/*
 * Only include the required header files once.
 */
#ifndef HEADERS_INCLUDED

#include "fut.h"
#include "fut_util.h"		/* internal interface file */
#include "interp.h"		/* interpolation macros and structures */

#define HEADERS_INCLUDED
#endif /* HEADERS_INCLUDED */

#if defined(DIM) && defined(BITS) && defined(ORDER)
/*---------------------------------------------- ORDER dependent macros */
#if ORDER==0
#undef	ONAME
#define ONAME()fut_interp_nn
#undef	INTERP1D
#define INTERP1D	fut_nn
#undef	INTERP2D
#define INTERP2D	fut_binn
#undef	INTERP3D
#define INTERP3D	fut_trinn
#undef	INTERP4D
#define INTERP4D	fut_quadnn
#else
#if ORDER==2
#undef	ONAME
#define ONAME()fut_interp_cub
#undef	INTERP1D
#define INTERP1D	fut_cub
#undef	INTERP2D
#define INTERP2D	fut_bicub
#undef	INTERP3D
#define INTERP3D	fut_tricub
#undef	INTERP4D
#define INTERP4D	fut_quadcub

#else /* ORDER==1 */
#undef	ONAME
#define ONAME()fut_interp_lin
#undef	INTERP1D
#define INTERP1D	fut_lin
#undef	INTERP2D
#define INTERP2D	fut_bilin
#undef	INTERP3D
#define INTERP3D	fut_trilin
#undef	INTERP4D
#define INTERP4D	fut_quadlin

#endif /* ORDER==2 */
#endif /* ORDER==0 */

/*---------------------------------------------- BITS dependent macros */
#if BITS==8
#undef	TYPE
#define TYPE		u_int8
#undef  TYPE_PTR
#define	TYPE_PTR	generic_u_int8_ptr_t
/*#undef	fut_interp_x
#define fut_interp_x	DNAME()8 */
#undef	INPUT
#define INPUT(x,itbl,t,p)	(itbl[x])
#undef	OUTPUT
#define OUTPUT(t)		FUT_OTBL_NINT (t)

#else
#if BITS==12
#undef	TYPE
#define TYPE		int16
#undef  TYPE_PTR
#define	TYPE_PTR	generic_int16_ptr_t
/*#undef	fut_interp_x
#define fut_interp_x	DNAME()12 */
#undef	INPUT
#define INPUT(x,itbl,t,p) 	FUT_ITBL_INTERP(itbl,x,t,p)
#undef	OUTPUT
#define OUTPUT(t)		(t)

#else /* BITS==0 */
#undef	TYPE
#define TYPE		int16
#undef  TYPE_PTR
#define	TYPE_PTR	generic_int16_ptr_t
/* #undef	fut_interp_x
#define fut_interp_x	DNAME()0 */
#undef	INPUT
#define INPUT(x,itbl,t,p)	(itbl[x])
#undef	OUTPUT
#define OUTPUT(t)		(t)

#endif /* BITS==12 */
#endif /* BITS==8 */

/*---------------------------------------------- DIM dependent macros */
#if DIM==1
#undef	ND
#define ND(a,b,c,d) a
#undef	ND1
#define ND1(a,b,c,d) TYPE_PTR a
#undef	ND2
#define ND2(a,b,c,d) fut_itbldat_ptr_t a
#undef	ND3
#define ND3(a,b,c,d) fut_gtbldat_ptr_t a
#undef	DNAME
#define DNAME()ONAME()1d
#undef	INTERP
#define INTERP	INTERP1D

#else
#if DIM==2
#undef	ND
#define ND(a,b,c,d) a,b
#undef	ND1
#define ND1(a,b,c,d) TYPE_PTR a, TYPE_PTR b
#undef	ND2
#define ND2(a,b,c,d) fut_itbldat_ptr_t a, fut_itbldat_ptr_t b
#undef	ND3
#define ND3(a,b,c,d) fut_gtbldat_ptr_t a, int32 b
#undef	DNAME
#define DNAME()ONAME()2d
#undef	INTERP
#define INTERP	INTERP2D

#else
#if DIM==3
#undef	ND
#define ND(a,b,c,d) a,b,c
#undef	ND1
#define ND1(a,b,c,d) TYPE_PTR a, TYPE_PTR b, TYPE_PTR c
#undef	ND2
#define ND2(a,b,c,d) fut_itbldat_ptr_t a, fut_itbldat_ptr_t b, fut_itbldat_ptr_t c
#undef	ND3
#define ND3(a,b,c,d) fut_gtbldat_ptr_t a, int32 b, int32 c
#undef	DNAME
#define DNAME()ONAME()3d
#undef	INTERP
#define INTERP	INTERP3D

#else /* DIM==4 */
#undef	ND
#define ND(a,b,c,d) a,b,c,d
#undef	ND1
#define ND1(a,b,c,d) TYPE_PTR a, TYPE_PTR b, TYPE_PTR c, TYPE_PTR d
#undef	ND2
#define ND2(a,b,c,d) fut_itbldat_ptr_t a, fut_itbldat_ptr_t b, fut_itbldat_ptr_t c, \
					 fut_itbldat_ptr_t d
#undef	ND3
#define ND3(a,b,c,d) fut_gtbldat_ptr_t a, int32 b, int32 c, int32 d
#undef	DNAME
#define DNAME()ONAME()4d
#undef	INTERP
#define INTERP	INTERP4D

#endif /* DIM==3 */
#endif /* DIM==2 */
#endif /* DIM==1 */


/*
 * fut_interp_x interpolates an array of values from a 1, 2, or 3 inputs arrays.
 * linear, bilinear, trilinear, cubic, bicubic, or tricubic interpolation is
 * performed depending on the definition of the macro INTERP.
 * 8-bit or 12-bit data is evaluated, depending on the definitions of the
 * macros TYPE, INPUT, and OUTPUT.
 * ND(a,b,c,d) produces	'a' for 1D, 'a,b' for 2D, 'a,b,c' for 3D, and 'a,b,c,d' for 4D.
 * NDIMSVD produces	'<nil>' for 1D, 'int32 nt;' for 2D, 'int32 nt,nz;' for 3D, and 'int32 nt,nz,ny;' for 4D.
 */
int
fut_interp_x (TYPE_PTR rp, ND1(tp,zp,yp,xp), int32 n, ND2(ttbl,ztbl,ytbl,xtbl),
				ND3(gtbl, nt,nz,ny), fut_otbldat_ptr_t otbl)
{
fut_interp_t interp_args;
fut_interp_t* iap = &interp_args;
fut_itbldat_t	r;	/* output value (and scratch) */
int	ND(t,z,y,x);	/* input value(s) */
#if BITS==12
	fut_itbldat_ptr_t	p;	/* scratch pointer */
#endif

/* if grid table pointer is NULL, save grace by copying 1st input to output. */
	if ( gtbl == NULL ) {
		bcopy((fut_generic_ptr_t)tp,(fut_generic_ptr_t)rp, sizeof(TYPE)*n);
		return (1);
	}

				/* set up grid table and dimensions in
				   arg structure for interpolator */
	( ND (iap->grid = gtbl, iap->nt = nt, iap->nz = nz, iap->ny = ny) );
	( ND (iap->st = GDATSIZE,			/* single stride for t dimension */
		iap->sz = iap->st * nt, 		/* single stride for z dimension */
		iap->sy = iap->sz * nz, 		/* single stride for y dimension */
		iap->sx = iap->sy * ny) );	/* single stride for x dimension */

	while ( --n >= 0 ) {

		( ND (	t = *tp++, z = *zp++, y = *yp++, x = *xp++ ) );	/* get (t), (t,z), (t,z,y), or (t,z,y,x) */

/* pass (t), (t,z), (t,z,y), or (t,z,y,x) through input tables and put in arg structure */
		( ND (	iap->gt = (int32)INPUT(t,ttbl,r,p),
			iap->gz = (int32)INPUT(z,ztbl,r,p),
			iap->gy = (int32)INPUT(y,ytbl,r,p),
			iap->gx = (int32)INPUT(x,xtbl,r,p) ) );

		r = INTERP(iap);			/* interpolate a value from grid table */

		if ( otbl != NULL ) {
			r = otbl[r];				/* pass result through output table */
		}

		*rp++ = (TYPE)OUTPUT (r);

	} /* while */

	return (1);
}

#else /* !(defined(DIM) && defined(BITS) && defined(ORDER) */
				/* generate all required versions of fut_interp_x */
/*
 * fut_interp_nop() is a function which does nothing and is used when an
 * illegal interpolation function is specified in fut_interp_fun (below).
 */
static int	fut_interp_nop ()
{
	return (0);
}

/*
 * fut_interp_fun() is a function which returns a pointer to the proper
 * interpolation function given the data type (0=8bit, 1=12bit, 2=12bit
 * with large input tables), interpolation order, and input dimension.
 */

fut_pfi_t0
	fut_interp_fun0 (int dattype, int order)
{

	switch (dattype) {

	    case 0:	/* interpolation of 8-bit data */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t0) fut_interp_0d8);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t0) fut_interp_0d8);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t0) fut_interp_0d8);
			break;
#endif
		}
		break;

	    case 1:	/* interpolation of 12-bit data with normal itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t0) fut_interp_0d12);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
				return ((fut_pfi_t0) fut_interp_0d12);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t0) fut_interp_0d12);
			break;
#endif
		}
		break;

	    case 2:	/* interpolation of 12-bit data with large itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t0) fut_interp_0d0);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t0) fut_interp_0d0);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t0) fut_interp_0d0);
			break;
#endif
		}
		break;
	}

	DIAG("fut_eval: illegal interpolation function\n", 0);
	DIAG("          Evaluation not performed!!\n", 0);

	return ((fut_pfi_t0) fut_interp_nop);
}

fut_pfi_t1
	fut_interp_fun1 (int dattype, int order)
{

	switch (dattype) {

	    case 0:	/* interpolation of 8-bit data */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t1) fut_interp_nn1d8);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t1) fut_interp_lin1d8);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t1) fut_interp_cub1d8);
			break;
#endif
		}
		break;

	    case 1:	/* interpolation of 12-bit data with normal itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t1) fut_interp_nn1d12);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t1) fut_interp_lin1d12);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t1) fut_interp_cub1d12);
			break;
#endif
		}
		break;

	    case 2:	/* interpolation of 12-bit data with large itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t1) fut_interp_nn1d0);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t1) fut_interp_lin1d0);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t1) fut_interp_cub1d0);
			break;
#endif
		}
		break;
	}

	DIAG("fut_eval: illegal interpolation function\n", 0);
	DIAG("          Evaluation not performed!!\n", 0);

	return ((fut_pfi_t1) fut_interp_nop);
}

fut_pfi_t2
	fut_interp_fun2 (int dattype, int order)
{

	switch (dattype) {

	    case 0:	/* interpolation of 8-bit data */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t2) fut_interp_nn2d8);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t2) fut_interp_lin2d8);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t2) fut_interp_cub2d8);
			break;
#endif
		}
		break;

	    case 1:	/* interpolation of 12-bit data with normal itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t2) fut_interp_nn2d12);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t2) fut_interp_lin2d12);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t2) fut_interp_cub2d12);
			break;
#endif
		}
		break;

	    case 2:	/* interpolation of 12-bit data with large itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t2) fut_interp_nn2d0);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t2) fut_interp_lin2d0);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t2) fut_interp_cub2d0);
			break;
#endif
		}
		break;
	}

	DIAG("fut_eval: illegal interpolation function\n", 0);
	DIAG("          Evaluation not performed!!\n", 0);

	return ((fut_pfi_t2) fut_interp_nop);
}

fut_pfi_t3
	fut_interp_fun3 (int dattype, int order)
{

	switch (dattype) {

	    case 0:	/* interpolation of 8-bit data */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t3) fut_interp_nn3d8);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t3) fut_interp_lin3d8);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t3) fut_interp_cub3d8);
			break;
#endif
		}
		break;

	    case 1:	/* interpolation of 12-bit data with normal itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t3) fut_interp_nn3d12);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t3) fut_interp_lin3d12);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t3) fut_interp_cub3d12);
			break;
#endif
		}
		break;

	    case 2:	/* interpolation of 12-bit data with large itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t3) fut_interp_nn3d0);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t3) fut_interp_lin3d0);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t3) fut_interp_cub3d0);
			break;
#endif
		}
		break;
	}

	DIAG("fut_eval: illegal interpolation function\n", 0);
	DIAG("          Evaluation not performed!!\n", 0);

	return ((fut_pfi_t3) fut_interp_nop);
}

fut_pfi_t4
	fut_interp_fun4 (int dattype, int order)
{

	switch (dattype) {

	    case 0:	/* interpolation of 8-bit data */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t4) fut_interp_nn4d8);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t4) fut_interp_lin4d8);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t4) fut_interp_cub4d8);
			break;
#endif
		}
		break;

	    case 1:	/* interpolation of 12-bit data with normal itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t4) fut_interp_nn4d12);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t4) fut_interp_lin4d12);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t4) fut_interp_cub4d12);
			break;
#endif
		}
		break;

	    case 2:	/* interpolation of 12-bit data with large itbls */

		switch (order) {

#if !defined(NO_FUT_NEAREST)
		    case FUT_NEAREST:
			    return ((fut_pfi_t4) fut_interp_nn4d0);
			break;
#endif
		    case FUT_DEFAULT:
		    case FUT_LINEAR:
			    return ((fut_pfi_t4) fut_interp_lin4d0);
			break;

#if !defined(NO_FUT_CUBIC)
		    case FUT_CUBIC:
			    return ((fut_pfi_t4) fut_interp_cub4d0);
			break;
#endif
		}
		break;
	}

	DIAG("fut_eval: illegal interpolation function\n", 0);
	DIAG("          Evaluation not performed!!\n", 0);

	return ((fut_pfi_t4) fut_interp_nop);
}


/*
 * fut_interp_0d8, fut_interp_0d12, and fut_interp_0d0 are functions to perform
 * interpolation from a 1*1*1 grid, in other words, a constant function.
 * They are very simple and are provided in order to allow fut_comp and
 * fut_eval to treat these cases uniformly with the rest (e.g. fut_interp_lin1d8,
 * fut_interp_lin2d8, etc).
 */
int
fut_interp_0d8 (generic_u_int8_ptr_t r, int32 n, fut_gtbldat_ptr_t grid,
				fut_otbldat_ptr_t otbl)
{
	int	t = FUT_OTBL_NINT ((otbl==0) ? *grid : otbl[*grid]);

	for (; --n >= 0; *r++ = (u_int8)t) {}
	return (1);
}

int
fut_interp_0d12 (generic_int16_ptr_t r, int32 n, fut_gtbldat_ptr_t grid,
					fut_otbldat_ptr_t otbl)
{
	int	t = (otbl==0) ? *grid : otbl[*grid];

	for (; --n >= 0; *r++ = (int16)t){}
	return (1);
}

int
fut_interp_0d0 (generic_int16_ptr_t r, int32 n, fut_gtbldat_ptr_t grid,
				fut_otbldat_ptr_t otbl)
{
	int	t = (otbl==0) ? *grid : otbl[*grid];

	for (; --n >= 0; *r++ = (int16)t){}
	return (1);
}

#undef	DIM
#define	DIM	1
#undef	BITS
#define	BITS	8

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn1d8
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
/* #include "interp.c" fut_interp_lin1d8 */
/* An optimized version of fut_interp_lin1d8 is separately coded. */

#if !defined(NO_FUT_CUBIC)
#undef	ORDER
#define	ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub1d8
#include "interp.c"
#endif

#undef	BITS
#define	BITS	12

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn1d12
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
#undef fut_interp_x
#define fut_interp_x  fut_interp_lin1d12
#include "interp.c"

#if !defined(NO_FUT_CUBIC)
#undef ORDER
#define ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub1d12
#include "interp.c"
#endif

#undef	BITS
#define	BITS	0

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn1d0
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
#undef fut_interp_x
#define fut_interp_x  fut_interp_lin1d0
#include "interp.c"

#if !defined(NO_FUT_CUBIC)
#undef ORDER
#define ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub1d0
#include "interp.c"
#endif

#undef	DIM
#define	DIM	2
#undef	BITS
#define	BITS	8

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn2d8
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
/* #include "interp.c" fut_interp_lin2d8 */
/* An optimized version of fut_interp_lin2d8 is separately coded. */

#if !defined(NO_FUT_CUBIC)
#undef	ORDER
#define	ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub2d8
#include "interp.c"
#endif

#undef	BITS
#define	BITS	12

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn2d12
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
#undef fut_interp_x
#define fut_interp_x  fut_interp_lin2d12
#include "interp.c"

#if !defined(NO_FUT_CUBIC)
#undef ORDER
#define ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub2d12
#include "interp.c"
#endif

#undef	BITS
#define	BITS	0

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn2d0
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
#undef fut_interp_x
#define fut_interp_x  fut_interp_lin2d0
#include "interp.c"

#if !defined(NO_FUT_CUBIC)
#undef ORDER
#define ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub2d0
#include "interp.c"
#endif

#undef	DIM
#define	DIM	3
#undef	BITS
#define	BITS	8

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn3d8
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
/* #include "interp.c" fut_interp_lin3d8 */
/* An optimized version of fut_interp_lin3d8 is separately coded. */

#if !defined(NO_FUT_CUBIC)
#undef	ORDER
#define	ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub3d8
#include "interp.c"
#endif

#undef	BITS
#define	BITS	12

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn3d12
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
#undef fut_interp_x
#define fut_interp_x  fut_interp_lin3d12
#include "interp.c"

#if !defined(NO_FUT_CUBIC)
#undef ORDER
#define ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub3d12
#include "interp.c"
#endif

#undef	BITS
#define	BITS	0

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn3d0
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
/* #include "interp.c" fut_interp_lin3d0 */
/* An optimized version of fut_interp_lin3d0 is separately coded. */

#if !defined(NO_FUT_CUBIC)
#undef ORDER
#define ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub3d0
#include "interp.c"
#endif

#undef	DIM
#define	DIM	4
#undef	BITS
#define	BITS	8

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn4d8
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
/* #include "interp.c" fut_interp_lin4d8 */
/* An optimized version of fut_interp_lin4d8 is separately coded. */

#if !defined(NO_FUT_CUBIC)
#undef	ORDER
#define	ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub4d8
#include "interp.c"
#endif

#undef	BITS
#define	BITS	12

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn4d12
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
#undef fut_interp_x
#define fut_interp_x  fut_interp_lin4d12
#include "interp.c"

#if !defined(NO_FUT_CUBIC)
#undef ORDER
#define ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub4d12
#include "interp.c"
#endif

#undef	BITS
#define	BITS	0

#if !defined(NO_FUT_NEAREST)
#undef	ORDER
#define	ORDER	0
#undef fut_interp_x
#define fut_interp_x  fut_interp_nn4d0
#include "interp.c"
#endif

#undef	ORDER
#define	ORDER	1
/* #include "interp.c" fut_interp_lin4d0 */
/* An optimized version of fut_interp_lin4d0 is separately coded. */

#if !defined(NO_FUT_CUBIC)
#undef ORDER
#define ORDER	2
#undef fut_interp_x
#define fut_interp_x  fut_interp_cub4d0
#include "interp.c"
#endif


#endif /* defined(DIM) && defined(BITS) && defined(ORDER) */

