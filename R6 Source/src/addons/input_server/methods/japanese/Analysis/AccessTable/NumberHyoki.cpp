/******************************************
ファイル名	:	BBGetNumYomiBe.cpp
機能		:	助数詞、数詞の切り出し　＆　読みを返す

作成日	:	98.1.23
******************************************/
#include <SupportDefs.h>
#include <string.h>
#include <malloc.h>
#include <File.h>
#include <Entry.h>
#include <ByteOrder.h>

#include"NumberHyoki.h"	

static unsigned char rule[3525] = {
0x0,0x0,0x0,0x10,0x0,0xc,0x0,0x16,0x0,0x79,
0x0,0x14,0x0,0x9,0x0,0x47,0x0,0x30,0x0,0x3f,
0x0,0x72,0x0,0xb9,0x0,0x21,0x0,0xda,0x0,0x78,
0x1,0x52,0x0,0x30,0x1,0x82,0x0,0xc,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0x30,0x32,0x30,0x30,0x30,0x30,0x30,0x30,0x32,0x30,
0x32,0x32,0x30,0x32,0x30,0x32,0x30,0x30,0x32,0x30,
0x30,0x30,0x32,0x32,0x30,0x32,0x30,0x32,0x30,0x30,
0x30,0x30,0x32,0x30,0x32,0x32,0x30,0x32,0x30,0x30,
0x30,0x30,0x32,0x30,0x32,0x30,0x32,0x32,0x30,0x32,
0x30,0x32,0x30,0x30,0x32,0x30,0x32,0x30,0x32,0x32,
0x30,0x32,0x30,0x32,0x32,0x30,0x32,0x30,0x32,0x30,
0x32,0x32,0x30,0x30,0x30,0x31,0x30,0x30,0x30,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x31,0x30,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x32,0x30,0x31,
0x30,0x30,0x32,0x30,0x30,0x30,0x32,0x30,0x30,0x32,
0x30,0x31,0x30,0x30,0x32,0x30,0x30,0x30,0x32,0x32,
0x30,0x30,0x30,0x32,0x30,0x30,0x31,0x30,0x32,0x30,
0x32,0x32,0x30,0x32,0x30,0x31,0x30,0x30,0x32,0x30,
0x32,0x30,0x32,0x32,0x34,0x35,0x35,0x33,0x33,0x35,
0x33,0x35,0x33,0x35,0x34,0x34,0x30,0x30,0x30,0x31,
0x30,0x30,0x32,0x30,0x32,0x30,0x32,0x32,0x35,0x35,
0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,0xe3,0x81,0x84,
0xe3,0x81,0xa1,0x20,0xe3,0x81,0xab,0xe3,0x81,0x83,
0x20,0xe3,0x81,0x95,0xe3,0x82,0x93,0x20,0xe3,0x82,
0x88,0xe3,0x82,0x93,0x20,0xe3,0x81,0x94,0xe3,0x81,
0x89,0x20,0xe3,0x82,0x8d,0xe3,0x81,0x8f,0x20,0xe3,
0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x81,0xaf,0xe3,
0x81,0xa1,0x20,0xe3,0x81,0x8d,0xe3,0x82,0x85,0xe3,
0x81,0x86,0x20,0xe3,0x81,0x98,0xe3,0x82,0x85,0xe3,
0x81,0x86,0x20,0xe3,0x82,0x83,0xe3,0x81,0x8f,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,0xe3,0x81,
0x84,0xe3,0x81,0xa1,0x20,0xe3,0x81,0xab,0x20,0xe3,
0x81,0x95,0xe3,0x82,0x93,0x20,0xe3,0x82,0x88,0xe3,
0x82,0x93,0x20,0xe3,0x81,0x94,0x20,0xe3,0x82,0x8d,
0xe3,0x81,0x8f,0x20,0xe3,0x81,0xaa,0xe3,0x81,0xaa,
0x20,0xe3,0x81,0xaf,0xe3,0x81,0xa1,0x20,0xe3,0x81,
0x8d,0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x81,
0x98,0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x82,
0x83,0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,0xe3,
0x81,0x84,0xe3,0x81,0xa1,0x20,0xe3,0x81,0xab,0x20,
0xe3,0x81,0x95,0xe3,0x82,0x93,0x20,0xe3,0x82,0x88,
0xe3,0x82,0x93,0x20,0xe3,0x81,0x94,0x20,0xe3,0x82,
0x8d,0xe3,0x81,0x8f,0x20,0xe3,0x81,0xaa,0xe3,0x81,
0xaa,0x20,0xe3,0x81,0xaf,0xe3,0x81,0xa1,0x20,0xe3,
0x81,0x8d,0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,
0x81,0x98,0xe3,0x82,0x85,0xe3,0x81,0xa3,0x20,0xe3,
0x82,0x83,0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,
0xe3,0x81,0x84,0xe3,0x81,0xa3,0x20,0xe3,0x81,0xab,
0x20,0xe3,0x81,0x95,0xe3,0x82,0x93,0x20,0xe3,0x82,
0x88,0xe3,0x82,0x93,0x20,0xe3,0x81,0x94,0x20,0xe3,
0x82,0x8d,0xe3,0x81,0x8f,0x20,0xe3,0x81,0xaa,0xe3,
0x81,0xaa,0x20,0xe3,0x81,0xaf,0xe3,0x81,0xa1,0x20,
0xe3,0x81,0x8d,0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,
0xe3,0x81,0x98,0xe3,0x82,0x85,0xe3,0x81,0xa3,0x20,
0xe3,0x82,0x83,0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,
0x20,0xe3,0x81,0x84,0xe3,0x81,0xa1,0x20,0xe3,0x81,
0xab,0x20,0xe3,0x81,0x95,0xe3,0x82,0x93,0x20,0xe3,
0x82,0x88,0xe3,0x82,0x93,0x20,0xe3,0x81,0x94,0x20,
0xe3,0x82,0x8d,0xe3,0x81,0xa3,0x20,0xe3,0x81,0xaa,
0xe3,0x81,0xaa,0x20,0xe3,0x81,0xaf,0xe3,0x81,0xa1,
0x20,0xe3,0x81,0x8d,0xe3,0x82,0x85,0xe3,0x81,0x86,
0x20,0xe3,0x81,0x98,0xe3,0x82,0x85,0xe3,0x81,0xa3,
0x20,0xe3,0x82,0x83,0xe3,0x81,0xa3,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0xe3,0x81,0x9c,0xe3,0x82,
0x8d,0x20,0xe3,0x81,0x84,0xe3,0x81,0xa3,0x20,0xe3,
0x81,0xab,0x20,0xe3,0x81,0x95,0xe3,0x82,0x93,0x20,
0xe3,0x82,0x88,0xe3,0x82,0x93,0x20,0xe3,0x81,0x94,
0x20,0xe3,0x82,0x8d,0xe3,0x81,0x8f,0x20,0xe3,0x81,
0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x81,0xaf,0xe3,0x81,
0xa3,0x20,0xe3,0x81,0x8d,0xe3,0x82,0x85,0xe3,0x81,
0x86,0x20,0xe3,0x81,0x98,0xe3,0x82,0x85,0xe3,0x81,
0xa3,0x20,0xe3,0x82,0x83,0xe3,0x81,0x8f,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0xe3,0x81,0x9c,0xe3,
0x82,0x8d,0x20,0xe3,0x81,0x84,0xe3,0x81,0xa3,0x20,
0xe3,0x81,0xab,0x20,0xe3,0x81,0x95,0xe3,0x82,0x93,
0x20,0xe3,0x82,0x88,0xe3,0x82,0x93,0x20,0xe3,0x81,
0x94,0x20,0xe3,0x82,0x8d,0xe3,0x81,0xa3,0x20,0xe3,
0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x81,0xaf,0xe3,
0x81,0xa1,0x20,0xe3,0x81,0x8d,0xe3,0x82,0x85,0xe3,
0x81,0x86,0x20,0xe3,0x81,0x98,0xe3,0x82,0x85,0xe3,
0x81,0xa3,0x20,0xe3,0x82,0x83,0xe3,0x81,0xa3,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xe3,0x81,0x9c,
0xe3,0x82,0x8d,0x20,0xe3,0x81,0x84,0xe3,0x81,0xa3,
0x20,0xe3,0x81,0xab,0x20,0xe3,0x81,0x95,0xe3,0x82,
0x93,0x20,0xe3,0x82,0x88,0xe3,0x82,0x93,0x20,0xe3,
0x81,0x94,0x20,0xe3,0x82,0x8d,0xe3,0x81,0xa3,0x20,
0xe3,0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x81,0xaf,
0xe3,0x81,0xa3,0x20,0xe3,0x81,0x8d,0xe3,0x82,0x85,
0xe3,0x81,0x86,0x20,0xe3,0x81,0x98,0xe3,0x82,0x85,
0xe3,0x81,0xa3,0x20,0xe3,0x82,0x83,0xe3,0x81,0xa3,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xe3,0x81,
0x9c,0xe3,0x82,0x8d,0x20,0xe3,0x81,0x84,0xe3,0x81,
0xa1,0x20,0xe3,0x81,0xab,0x20,0xe3,0x81,0x95,0xe3,
0x82,0x93,0x20,0xe3,0x81,0x97,0x20,0xe3,0x81,0x94,
0x20,0xe3,0x82,0x8d,0xe3,0x81,0x8f,0x20,0xe3,0x81,
0x97,0xe3,0x81,0xa1,0x20,0xe3,0x81,0xaf,0xe3,0x81,
0xa1,0x20,0xe3,0x81,0x8f,0x20,0xe3,0x81,0x98,0xe3,
0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x82,0x83,0xe3,
0x81,0x8f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xe3,
0x81,0x9c,0xe3,0x82,0x8d,0x20,0xe3,0x81,0x84,0xe3,
0x81,0xa1,0x20,0xe3,0x81,0xab,0x20,0xe3,0x81,0x95,
0xe3,0x82,0x93,0x20,0xe3,0x82,0x88,0xe3,0x82,0x93,
0x20,0xe3,0x81,0x94,0x20,0xe3,0x82,0x8d,0xe3,0x81,
0x8f,0x20,0xe3,0x81,0x97,0xe3,0x81,0xa1,0x20,0xe3,
0x81,0xaf,0xe3,0x81,0xa1,0x20,0xe3,0x81,0x8f,0x20,
0xe3,0x81,0x98,0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,
0xe3,0x82,0x83,0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,0xe3,0x81,0x84,
0xe3,0x81,0xa1,0x20,0xe3,0x81,0xab,0x20,0xe3,0x81,
0x95,0xe3,0x82,0x93,0x20,0xe3,0x82,0x88,0xe3,0x82,
0x93,0x20,0xe3,0x81,0x94,0x20,0xe3,0x82,0x8d,0xe3,
0x81,0x8f,0x20,0xe3,0x81,0x97,0xe3,0x81,0xa1,0x20,
0xe3,0x81,0xaf,0xe3,0x81,0xa1,0x20,0xe3,0x81,0x8d,
0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x81,0x98,
0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x82,0x83,
0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,0xe3,0x81,
0xb2,0xe3,0x81,0xa8,0x20,0xe3,0x81,0xb5,0xe3,0x81,
0x9f,0x20,0xe3,0x81,0xbf,0x20,0xe3,0x82,0x88,0x20,
0xe3,0x81,0x84,0xe3,0x81,0xa4,0x20,0xe3,0x82,0x80,
0x20,0xe3,0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x82,
0x84,0x20,0xe3,0x81,0x93,0xe3,0x81,0x93,0xe3,0x81,
0xae,0x20,0xe3,0x81,0xa8,0xe3,0x81,0x86,0x20,0xe3,
0x82,0x83,0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,0xe3,
0x81,0xb2,0xe3,0x81,0xa8,0x20,0xe3,0x81,0xb5,0xe3,
0x81,0x9f,0x20,0xe3,0x81,0x95,0xe3,0x82,0x93,0x20,
0xe3,0x82,0x88,0xe3,0x82,0x93,0x20,0xe3,0x81,0x94,
0x20,0xe3,0x82,0x8d,0xe3,0x81,0x8f,0x20,0xe3,0x81,
0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x82,0x84,0x20,0xe3,
0x81,0x8d,0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,
0x81,0x98,0xe3,0x82,0x85,0xe3,0x81,0xa3,0x20,0xe3,
0x82,0x83,0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,
0xe3,0x81,0xb2,0xe3,0x81,0xa8,0x20,0xe3,0x81,0xb5,
0xe3,0x81,0x9f,0x20,0xe3,0x81,0xbf,0x20,0xe3,0x82,
0x88,0x20,0xe3,0x81,0x94,0x20,0xe3,0x82,0x8d,0xe3,
0x81,0x8f,0x20,0xe3,0x81,0xaa,0xe3,0x81,0xaa,0x20,
0xe3,0x81,0xaf,0xe3,0x81,0xa1,0x20,0xe3,0x81,0x8d,
0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x81,0x98,
0xe3,0x82,0x85,0xe3,0x81,0xa3,0x20,0xe3,0x82,0x83,
0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,
0x20,0xe3,0x81,0xb2,0xe3,0x81,0xa8,0x20,0xe3,0x81,
0xb5,0xe3,0x81,0x9f,0x20,0xe3,0x81,0xbf,0x20,0xe3,
0x82,0x88,0x20,0xe3,0x81,0x94,0x20,0xe3,0x82,0x8d,
0xe3,0x81,0xa3,0x20,0xe3,0x81,0xaa,0xe3,0x81,0xaa,
0x20,0xe3,0x81,0xaf,0xe3,0x81,0xa1,0x20,0xe3,0x81,
0x8d,0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x81,
0x98,0xe3,0x82,0x85,0xe3,0x81,0xa3,0x20,0xe3,0x82,
0x83,0xe3,0x81,0xa3,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0xe3,0x81,0x9c,0xe3,0x82,
0x8d,0x20,0xe3,0x81,0xb2,0xe3,0x81,0xa8,0x20,0xe3,
0x81,0xb5,0xe3,0x81,0x9f,0x20,0xe3,0x81,0x95,0xe3,
0x82,0x93,0x20,0xe3,0x82,0x88,0xe3,0x82,0x93,0x20,
0xe3,0x81,0x94,0x20,0xe3,0x82,0x8d,0xe3,0x81,0xa3,
0x20,0xe3,0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x81,
0xaf,0xe3,0x81,0xa1,0x20,0xe3,0x81,0x8d,0xe3,0x82,
0x85,0xe3,0x81,0x86,0x20,0xe3,0x81,0x98,0xe3,0x82,
0x85,0xe3,0x81,0xa3,0x20,0xe3,0x82,0x83,0xe3,0x81,
0xa3,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0xe3,0x81,0x9c,0xe3,
0x82,0x8d,0x20,0xe3,0x81,0xb2,0xe3,0x81,0xa8,0x20,
0xe3,0x81,0xb5,0xe3,0x81,0x9f,0x20,0xe3,0x81,0x95,
0xe3,0x82,0x93,0x20,0xe3,0x82,0x88,0xe3,0x82,0x93,
0x20,0xe3,0x81,0x94,0x20,0xe3,0x82,0x8d,0xe3,0x81,
0x8f,0x20,0xe3,0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,
0x81,0xaf,0xe3,0x81,0xa1,0x20,0xe3,0x81,0x8d,0xe3,
0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x81,0x98,0xe3,
0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,0x82,0x83,0xe3,
0x81,0x8f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xe3,0x82,0x8c,
0xe3,0x81,0x84,0x20,0xe3,0x81,0x84,0xe3,0x81,0xa1,
0x20,0xe3,0x81,0xab,0x20,0xe3,0x81,0x95,0xe3,0x82,
0x93,0x20,0xe3,0x82,0x88,0x20,0xe3,0x81,0x94,0x20,
0xe3,0x82,0x8d,0xe3,0x81,0x8f,0x20,0xe3,0x81,0x97,
0xe3,0x81,0xa1,0x20,0xe3,0x81,0xaf,0xe3,0x81,0xa1,
0x20,0xe3,0x81,0x8f,0x20,0xe3,0x81,0x98,0xe3,0x82,
0x85,0xe3,0x81,0x86,0x20,0xe3,0x82,0x83,0xe3,0x81,
0x8f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xe3,0x82,
0x8c,0xe3,0x81,0x84,0x20,0xe3,0x81,0x84,0xe3,0x81,
0xa1,0x20,0xe3,0x81,0xab,0x20,0xe3,0x81,0x95,0xe3,
0x82,0x93,0x20,0xe3,0x82,0x88,0xe3,0x82,0x93,0x20,
0xe3,0x81,0x94,0x20,0xe3,0x82,0x8d,0xe3,0x81,0x8f,
0x20,0xe3,0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x81,
0xaf,0xe3,0x81,0xa1,0x20,0xe3,0x81,0x8f,0x20,0xe3,
0x81,0x98,0xe3,0x82,0x85,0xe3,0x81,0x86,0x20,0xe3,
0x82,0x83,0xe3,0x81,0x8f,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xe3,
0x82,0x8c,0xe3,0x81,0x84,0x20,0xe3,0x81,0x84,0xe3,
0x81,0xa1,0x20,0xe3,0x81,0xab,0x20,0xe3,0x81,0x95,
0xe3,0x82,0x93,0x20,0xe3,0x82,0x88,0x20,0xe3,0x81,
0x94,0x20,0xe3,0x82,0x8d,0xe3,0x81,0x8f,0x20,0xe3,
0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x81,0xaf,0xe3,
0x81,0xa1,0x20,0xe3,0x81,0x8d,0xe3,0x82,0x85,0xe3,
0x81,0x86,0x20,0xe3,0x81,0x98,0xe3,0x82,0x85,0xe3,
0x81,0x86,0x20,0xe3,0x82,0x83,0xe3,0x81,0x8f,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0xe3,0x82,0x8c,0xe3,0x81,0x84,0x20,0xe3,0x81,0x84,
0xe3,0x81,0xa3,0x20,0xe3,0x81,0xab,0xe3,0x81,0x83,
0x20,0xe3,0x81,0x95,0xe3,0x82,0x93,0x20,0xe3,0x82,
0x88,0xe3,0x82,0x93,0x20,0xe3,0x81,0x94,0xe3,0x81,
0x89,0x20,0xe3,0x82,0x8d,0xe3,0x81,0x8f,0x20,0xe3,
0x81,0xaa,0xe3,0x81,0xaa,0x20,0xe3,0x81,0xaf,0xe3,
0x81,0xa1,0x20,0xe3,0x81,0x8d,0xe3,0x82,0x85,0xe3,
0x81,0x86,0x20,0xe3,0x81,0x98,0xe3,0x82,0x85,0xe3,
0x81,0xa3,0x20,0xe3,0x82,0x83,0xe3,0x81,0x8f,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0xe3,0x81,0x9c,0xe3,0x82,0x8d,0x20,0xe3,0x82,
0x8f,0xe3,0x82,0x93,0x20,0xe3,0x81,0xa4,0xe3,0x83,
0xbc,0x20,0xe3,0x81,0x99,0xe3,0x82,0x8a,0xe3,0x83,
0xbc,0x20,0xe3,0x81,0xb5,0xe3,0x81,0x89,0xe3,0x83,
0xbc,0x20,0xe3,0x81,0xb5,0xe3,0x81,0x81,0xe3,0x81,
0x84,0xe3,0x81,0xb6,0x20,0xe3,0x81,0x97,0xe3,0x81,
0xa3,0xe3,0x81,0x8f,0xe3,0x81,0x99,0x20,0xe3,0x81,
0x9b,0xe3,0x81,0xb6,0xe3,0x82,0x93,0x20,0xe3,0x81,
0x88,0xe3,0x81,0x84,0xe3,0x81,0xa8,0x20,0xe3,0x81,
0xaa,0xe3,0x81,0x84,0xe3,0x82,0x93,0x20,0xe3,0x81,
0xa6,0xe3,0x82,0x93,0x20,0xe3,0x82,0x83,0xe3,0x81,
0x8f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0xe3,0x81,0x8b,0xe3,0x81,0x8c,0xe3,0x81,
0x8c,0xe3,0x81,0x8d,0xe3,0x81,0x8e,0xe3,0x81,0x8e,
0xe3,0x81,0x8f,0xe3,0x81,0x90,0xe3,0x81,0x90,0xe3,
0x81,0x91,0xe3,0x81,0x92,0xe3,0x81,0x92,0xe3,0x81,
0x93,0xe3,0x81,0x94,0xe3,0x81,0x94,0xe3,0x81,0x95,
0xe3,0x81,0x96,0xe3,0x81,0x96,0xe3,0x81,0x97,0xe3,
0x81,0x98,0xe3,0x81,0x98,0xe3,0x81,0x99,0xe3,0x81,
0x9a,0xe3,0x81,0x9a,0xe3,0x81,0x9b,0xe3,0x81,0x9c,
0xe3,0x81,0x9c,0xe3,0x81,0x9d,0xe3,0x81,0x9e,0xe3,
0x81,0x9e,0xe3,0x81,0x9f,0xe3,0x81,0xa0,0xe3,0x81,
0xa0,0xe3,0x81,0xa1,0xe3,0x81,0xa2,0xe3,0x81,0xa2,
0xe3,0x81,0xa4,0xe3,0x81,0xa5,0xe3,0x81,0xa5,0xe3,
0x81,0xa6,0xe3,0x81,0xa7,0xe3,0x81,0xa7,0xe3,0x81,
0xa8,0xe3,0x81,0xa9,0xe3,0x81,0xa9,0xe3,0x81,0xaf,
0xe3,0x81,0xb0,0xe3,0x81,0xb1,0xe3,0x81,0xb2,0xe3,
0x81,0xb3,0xe3,0x81,0xb4,0xe3,0x81,0xb5,0xe3,0x81,
0xb6,0xe3,0x81,0xb7,0xe3,0x81,0xb8,0xe3,0x81,0xb9,
0xe3,0x81,0xba,0xe3,0x81,0xbb,0xe3,0x81,0xbc,0xe3,
0x81,0xbd,0xef,0xbc,0x88,0xef,0xbc,0x89,0xe3,0x80,
0x94,0xe3,0x80,0x95,0xef,0xbc,0xbb,0xef,0xbc,0xbd,
0xef,0xbd,0x9b,0xef,0xbd,0x9d,0xe3,0x80,0x88,0xe3,
0x80,0x89,0xe3,0x80,0x8a,0xe3,0x80,0x8b,0xe3,0x80,
0x8c,0xe3,0x80,0x8d,0xe3,0x80,0x8e,0xe3,0x80,0x8f,
0xe3,0x80,0x90,0xe3,0x80,0x91,0xe2,0x80,0x94,0xe2,
0x88,0x92,0xef,0xbc,0x9a,0x2d,0x28,0x29,0x5b,0x5d,
0x3c,0x3e,0x3a,0xef,0xbc,0x8e,0xe3,0x80,0x87,0xe9,
0x9b,0xb6,0xe4,0xb8,0x80,0xe5,0xa3,0xb1,0xe4,0xba,
0x8c,0xe5,0xbc,0x90,0xe8,0xb2,0xb3,0xe4,0xb8,0x89,
0xe5,0x8f,0x82,0xe5,0x9b,0x9b,0xe4,0xba,0x94,0xe4,
0xbc,0x8d,0xe5,0x85,0xad,0xe4,0xb8,0x83,0xe5,0x85,
0xab,0xe4,0xb9,0x9d,0xef,0xbc,0x90,0xef,0xbc,0x91,
0xef,0xbc,0x92,0xef,0xbc,0x93,0xef,0xbc,0x94,0xef,
0xbc,0x95,0xef,0xbc,0x96,0xef,0xbc,0x97,0xef,0xbc,
0x98,0xef,0xbc,0x99,0xe4,0xbd,0x95,0xe6,0x95,0xb0,
0xe5,0x8d,0x81,0xe6,0x8b,0xbe,0xe7,0x99,0xbe,0xe5,
0x8d,0x83,0xe4,0xb8,0x87,0xe8,0x90,0xac,0xe5,0x84,
0x84,0xe5,0x85,0x86,0xef,0xbc,0x8c,0xef,0xbc,0x8e,
0xef,0xbc,0x8c,0xe3,0x80,0x80,0xe3,0x81,0xa3,0xe3,
0x81,0xb2,0xe3,0x81,0xb3,0xe3,0x81,0xb4,0xe3,0x81,
0xaa,0xe3,0x82,0x93,0xe3,0x81,0x99,0xe3,0x81,0x86,
0xe3,0x81,0xa6,0xe3,0x82,0x93,0xe3,0x82,0x8c,0xe3,
0x81,0x84,0xe3,0x81,0xa6,0xe3,0x82,0x93,0xe3,0x81,
0x84,0xe3,0x81,0xa3,0xe3,0x82,0x8d,0xe3,0x81,0xa3,
0xe3,0x81,0xaf,0xe3,0x81,0xa3,0xe3,0x81,0x98,0xe3,
0x82,0x85,0xe3,0x81,0x86,0xe3,0x81,0x98,0xe3,0x82,
0x85,0xe3,0x81,0xa3,0xe3,0x81,0xb2,0xe3,0x82,0x83,
0xe3,0x81,0x8f,0xe3,0x81,0xb3,0xe3,0x82,0x83,0xe3,
0x81,0x8f,0xe3,0x81,0xb4,0xe3,0x82,0x83,0xe3,0x81,
0x8f,0xe3,0x81,0x9b,0xe3,0x82,0x93,0xe3,0x81,0x9c,
0xe3,0x82,0x93,0xe3,0x81,0xbe,0xe3,0x82,0x93,0xe3,
0x81,0x8a,0xe3,0x81,0x8f,0xe3,0x81,0xa1,0xe3,0x82,
0x87,0xe3,0x81,0x86,0xe3,0x81,0x91,0xe3,0x81,0x84,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,
0x2e,0x2c,0xef,0xbc,0x90,0xef,0xbc,0x91,0xef,0xbc,
0x92,0xef,0xbc,0x93,0xef,0xbc,0x94,0xef,0xbc,0x95,
0xef,0xbc,0x96,0xef,0xbc,0x97,0xef,0xbc,0x98,0xef,
0xbc,0x99,0xef,0xbc,0x8e,0xef,0xbc,0x8c,0xef,0xbc,
0x90,0xef,0xbc,0x90,0xef,0xbc,0x90,0xef,0xbc,0x90,
0xef,0xbc,0x90,0xef,0xbc,0x90,0xef,0xbc,0x90,0xef,
0xbc,0x90,0xef,0xbc,0x90,0xef,0xbc,0x90,0xef,0xbc,
0x90,0xef,0xbc,0x90,0xef,0xbc,0x90,0xef,0xbc,0x90,
0xef,0xbc,0x90,0xef,0xbc,0x90,0xef,0xbc,0x90,0xef,
0xbc,0x90,0xef,0xbc,0x90,0xef,0xbc,0x90,0xef,0xbc,
0x90,0xef,0xbc,0x90,0x00 } ;

//////////////////

/***************************************************************
関数名	:	NumberHyoki::NumberHyoki
機能		:	コンストラクタ
入力		:	なし
出力		:	なし
作成日	:	98.2.16
***************************************************************/
NumberHyoki::NumberHyoki()
{
	fHeader.disk_mask = 0;
	
	fHeader.rule1Num[0] = 16;
	fHeader.rule1Num[1] = 12;
	
	fHeader.rule2Num[0] = 22;
	fHeader.rule2Num[1] = 121;
	
	fHeader.rule3Num[0] = 20;
	fHeader.rule3Num[1] = 9;
	
	fHeader.rule4Num[0] = 71;
	fHeader.rule4Num[1] = 48;
	fHeader.rule4Num[2] = 63;
	
	fHeader.rule5Num[0] = 114;
	fHeader.rule5Num[1] = 185;
	
	fHeader.rule6Num[0] = 33;
	fHeader.rule6Num[1] = 218;
	
	fHeader.rule7Num[0] = 120;
	fHeader.rule7Num[1] = 338;
	
	fHeader.rule8Num[0] = 48;
	fHeader.rule8Num[1] = 386;
	fHeader.rule8Num[2] = 12;
}

/***************************************************************
関数名	:	NumberHyoki::GetYomiNum
機能		:	かな漢字変換用　個別の数詞を連続した数詞に変換する
入力		:	at						アクセステーブル
			input					入力文字列
			analyzeStrLength			入力文字列の長さ
			searchStrLength			最下位の数字の長さ
出力		:	変換された数
作成日	:	98.1.23
***************************************************************/
int NumberHyoki::GetYomiNum(AccessTable& at,const uchar *input, short analyzeStrLength, short searchStrLength)
{
	int returnNum ;				//返す個数
	int returnNumBak ;			//桁数が一つ少ない時点での返す個数
	int dummy ;				//ダミー
	int length[NumHyokiMax+1] ;	//おのおのの数詞の長さ
	int turn ;					//繰り返す回数（数詞の桁数）
	short times ;				//連続している数詞の個数
	char inputBak[strSize] ;		//入力部保存用
	int lengthHankaku ;			//変換された半角の長さ	
	int lengthInput ;				//入力文字列or半角→全角変換後の長さ
	short i ;					//作業用	
	int cutOverFlowLength;	//解析に関係ない上部のカットした長さ
	short analyzeStrLengthBak ;	//analyzeStrLength保存用
	
	NumberHeader	header[MaxNumYomi] ;		//数字用ルール
	
	lengthHankaku = 0 ;
	
	analyzeStrLengthBak = analyzeStrLength ;
	cutOverFlowLength = 0 ;	

	if ( kInputBakLength> analyzeStrLengthBak ) {	
		strncpy ( inputBak , (char*)input, analyzeStrLengthBak ) ;			//inputを保存	
		inputBak[analyzeStrLengthBak] = '\0';	
		}
	else {
		strncpy ( inputBak , (char*)&input[analyzeStrLengthBak-kInputBakLength], kInputBakLength ) ;			//inputを保存	
		inputBak[kInputBakLength] = '\0';
		analyzeStrLengthBak = kInputBakLength ;
		cutOverFlowLength = analyzeStrLengthBak-kInputBakLength	;
		}

	lengthInput = (int)analyzeStrLengthBak ;

#if 1 
/*	
半角フィルタ部
*/	
/*
	if ( CheckHankaku( inputBak , analyzeStrLengthBak - 1 ) == 1 ) 	{	
		lengthHankaku = ChangeNumToNum(inputBak , analyzeStrLengthBak , 0 , 0 , 0) ;
		searchStrLength = kLengthZenkaku ;
		}

	lengthInput = strlen(inputBak) ;	
*/
	if ( CheckHankaku( inputBak , analyzeStrLengthBak - kLengthZenkaku ) != kLengthZenkaku ){
		/* 全角以外はなにもしない */	
		return 0 ;
		}
#endif

	
	dummy = 0 ;
	times = 1 ;		//個数を１に設定
	length[0] = (int)searchStrLength ;		//最下位の数詞の長さを保存
		
	if ( lengthInput - (int)searchStrLength == 0 ) {		//数詞一つのみ
		return 0 ;			//読む必要がない					
		}

	if ( lengthHankaku > 0 ) {	
		if ( lengthHankaku < 2 ) return 0 ;	//数詞が一つ
		times = lengthHankaku ;	
		dummy = lengthHankaku * kLengthZenkaku - (int)searchStrLength ;	
		for ( i = 1 ; i < lengthHankaku ; i++ ) {		//lengthの設定
			length[i] = length[ i - 1]+kLengthZenkaku ;
			}
		}
	else {
		dummy += GetNumLength( at , lengthInput - (int)searchStrLength , &times, length,  cutOverFlowLength) ;	//数詞の長さを得る	
		if ( times < 2 || dummy == 0 ) {		//数詞が一つしかない or 一つもない
			return 0 ;					//読む必要がないため0を返す。
			}
		}

	if ( times > kMaxNumKeta ) {		//変換できる桁数を超えた
		if ( lengthHankaku > 0 ) {	
			SetNumsOut( 1 , 0 , lengthHankaku , 0) ;	
			if ( kMaxHyokiSize <= lengthHankaku ) return 0 ;
			strncpy( numberHyoki[0].hyoki , (char*)&input[analyzeStrLengthBak-lengthHankaku] ,  lengthHankaku) ;
			numberHyoki[0].hyoki[lengthHankaku] = '\0';
			return 1 ;
			}
		SetNumsOut(1 , 0 , dummy + (int)searchStrLength , 0) ;	
		if ( ( (int)searchStrLength + dummy ) < kMaxHyokiSize ) {
			strcpy( numberHyoki[0].hyoki , &inputBak[analyzeStrLengthBak-(int)searchStrLength-dummy]  ) ;	
			for ( turn = lengthInput-(int)searchStrLength-dummy ; turn < lengthInput ; turn += kLengthZenkaku ) {	
				if ( NumsToNum( &inputBak[turn] ) == -1 ) {		//「１２３４５６７８９０」ではない
					return 0 ;
					}
				}
			return 1 ;
			}					
		return 0 ;				
		}

	if ( CheckNumToHyoukiSize( ( times + 1 ) * kLengthZenkaku ) != 0 ) {
		return 0 ;
		}

	SetYomiNum(&header[0] ) ;	//ルールの設定
	
	returnNum = 0 ;			//初期化
	returnNumBak = 0 ;			//初期化
		
	for ( turn = 1 ; turn < times ; turn++ ) {		//数詞の個数だけ繰り返す

		dummy = 	GetNumYomi (inputBak,  lengthInput ,header , &returnNum , returnNumBak , turn , length , lengthHankaku) ;
		if ( dummy < 0 ) {					//変換できない
			returnNum = returnNumBak ;		//もとに戻す
			}
		returnNumBak = returnNum ;
		}

	return returnNum ;		//変換した個数を返す
		
}

/***************************************************************
関数名	:	NumberHyoki::CheckNumToHyoukiSize
機能		:	入力数字から漢数字の変換の際，考えられる最大桁数を推測し，hyokiSizeに格納可能かどうか調べる
入力		:	numLength			入力数字列の長さ
出力		:	0	格納可能
			-1	格納不可能
作成日	:	98.1.23
***************************************************************/
int NumberHyoki::CheckNumToHyoukiSize(int numLength) 
{

	if ( numLength * 2 > kMaxHyokiSize ) {	//数字列に対して最大２倍の漢数字列を生成する可能性がある。
		return -1 ;				//例：「３３３３」→「三千三百三十三」
		}

	return 0 ;
	
}

/***************************************************************
関数名	:	NumberHyoki::NumsSortCheck
機能		:	数詞と数詞の整合性を検査する
入力		:	nowNumber		現在の数字
			bakNumber		一つ前の数字
出力		:	0	読むことが出来る
			-1	読むことが出来ない
作成日	:	98.1.23
***************************************************************/
int NumberHyoki::NumsSortCheck( int nowNumber , int bakNumber) 

{

/*にぃ　ごぉ　よ　く　で，ひとけた目で無い場合*/
	if ( bakNumber == 2 || bakNumber == 5 || bakNumber == 12 || bakNumber == 13 ) {
		return -1 ;
		}
/*さん　なん　と，　ぜん　びゃく　の場合*/
	if ( ( bakNumber != 3 && bakNumber!= 27 ) && ( nowNumber == 23 || nowNumber == 20 ) ) {
		return -1 ;
		}
		
/*ろっ　はっ　と，　ぴゃく　の場合*/
	if ( ( bakNumber == 15 || bakNumber== 16 ) && nowNumber == 21 ) {
		return 0 ;
		}
	else if  ( nowNumber == 21) {
		return -1 ;
		}
/*ろっ　はっ　と，　それ以外　の場合*/
	if ( ( bakNumber == 15 || bakNumber== 16 )  && nowNumber > 16 ) {
		return -1 ;
		}

	return 0 ;
}

/***************************************************************
関数名	:	NumberHyoki::GetNumYomi
機能		:	かな漢用数詞変換解析部
入力		:	inputBak				入力文字列
			analyzeStrLength		入力文字列の長さ
			searchStrLength		最下位の数詞の長さ
			header				数詞のルール
			returnNum				返す個数
			returnNumBak			桁数が一つ少ない時点での返す個数
			turn					繰り返す回数（数詞の桁数）
			length				おのおのの数詞の長さ
出力		:	0			成功
			-1			失敗
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
int NumberHyoki::GetNumYomi(char *inputBak, short analyzeStrLength ,
					NumberHeader *header , int *returnNum , int returnNumBak, int turn  , int length[] , int lengthHankaku )


{
	int numCheck ;		//読みor数字のcheck用
	int lengthNum ;		// 	kLengthNum / kLengthZenkaku
	int dummy ;		//ダミー
	int cutIchi ;		//漢数字の区切り位置
	int bakNum ;		//前の数字		//	0 「〇一二三四五六七八九数何」
	short i , j ;		//作業用
	short pass , levelFlag , levelFlag2 ;				//LevelFlag	1	「何」・「数」
											//LevelFlag	2	入力が「１２３」など
	short strLength ;				//Level2用変換文字列の長さ
	short numFlag ;				//「〇一二三四五六七八九数何」の検査用
	char hyouki[kMaxHyokiSize] ;			//数字表記（漢数字）
	char hyouki2[kMaxHyokiSize] ;			//数字表記（数字）
	char hyouki3[kMaxHyokiSize] ;			//数字表記（半角及び漢数字）
	jyosuCodeHeader	*hankakuHeader;
	unsigned char		*p,*tmpPtr;

	hankakuHeader = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		hankakuHeader->rule1Num[1]*hankakuHeader->rule1Num[0] + hankakuHeader->rule2Num[1]*hankakuHeader->rule2Num[0]
			+hankakuHeader->rule3Num[1]*hankakuHeader->rule3Num[0]+hankakuHeader->rule7Num[1];	

	p = tmpPtr ;
	
	if ( (*returnNum) > NumHyokiMax - kNumHenkanLevel ) return -1 ; 	//returnNumのover

	hyouki[0] = '\0' ;
	hyouki2[0] = '\0' ;
	hyouki3[0] = '\0' ;
	pass = 0 ;
	levelFlag = 0 ;
	levelFlag2 = 0 ;
	numCheck = 0 ;
	cutIchi = 0 ; 
	bakNum =  -1 ;
	numCheck = 0 ;
	numFlag = 0 ;	
		
	lengthNum = kLengthNum / kLengthZenkaku ;

		numCheck = NumToKnum( &inputBak[analyzeStrLength - length[ turn ] - length[0] ] , hyouki , header , 0) ;		//与える変数は仮（動作確認済）
		if ( numCheck != 0 ) {		//与えられた数詞が「読み」
			if ( numCheck < -1 ) {		//「１に」等になっている
				return -1 ;
				}
			hyouki[0] = '\0' ;			//初期化
			for ( i = analyzeStrLength - length[ turn ] - length[0] ; i < analyzeStrLength ; i+= pass ) {		//入力は数字のみ
				for ( j = 0 ; j < kLengthNumYomi + kSpecialJosuNum ; j++ ) {						//解析ループ
					if ( !strncmp( &inputBak[i] , header[j].yomi , header[j].yomiLength ) ) {			//見つかった
						//「〇一二三四五六七八九数何」が続く
						if ( numFlag == 1  && ( j < kLengthNumYomi -  lengthNum || j > kLengthNumYomi - 1 ) ) {	
							return -1 ;		//失敗
							}
						if ( NumsSortCheck( j , bakNum ) != 0 ) return -1 ;		//数字の整合性の検査
						if ( j > ( kLengthNumYomi -  lengthNum ) -1 ) levelFlag2 = 1 ;		//十や百などが存在
						if ( j > kLengthNumYomi - 1 ) levelFlag = 1 ;					//数や何が存在
						if ( i == analyzeStrLength - length[ turn ] - length[0] && j > kMyriadNumDef - 1 && j < kLengthNumYomi )  {	//先頭が「万億兆」
							return -1 ;		//失敗
							}
						strncat( hyouki , header[j].numHyouki.kanjiNum  , kLengthZenkaku) ;		//変換された数字の付加
						pass = header[j].yomiLength ;						//変換された数字長さ
						if ( j < kLengthNumYomi -  lengthNum || j > kLengthNumYomi - 1 ) {	//「〇一二三四五六七八九数何」
							numFlag = 1 ;	//1にする
							}
						else {
							numFlag = 0 ;
							}
						bakNum = j ;
						break ;
						}
					}
				if ( j == kLengthNumYomi + kSpecialJosuNum ) {		//解析失敗
					return -1 ;		//失敗
					}
				}
			}
		else {
			/*
			与えられた数詞が１２３４・・・なのだから
			Level 2は入力をそのまま返すだけでいい
			*/
			levelFlag2 = 2 ;
			}
		
		if ( levelFlag2 == 0 ) {	//「十百千万・・・」などが存在しない
			return -1 ;		//失敗
			}
			
		if ( levelFlag2 == 2 ) {						//入力が１２３・・・
			strcpy( numberHyoki[*returnNum].hyoki , &inputBak[analyzeStrLength - length[ turn ] - length[0]] ) ;		//Level1解析文字列
			(*returnNum)++ ;								//Level1終了
			}
		else	{									//入力が読み
			strcpy( numberHyoki[*returnNum].hyoki , hyouki ) ;		//Level1解析文字列
			(*returnNum)++ ;								//Level1終了
			
			}

		if ( kNumHenkanLevel > 1 && levelFlag == 0 ) {			//Level2解析開始
			if ( levelFlag2 == 2 ) {						//入力が１２３・・・
				strcpy( hyouki2 , hyouki ) ;				//漢数字が出力
				}
			else {									//入力が読み
				cutIchi = KnumtoNum (hyouki , hyouki2 ) ;		//漢数字 -> 数字
				if ( cutIchi != 0 ) {	//漢数字の並びが正しくない
					return -1 ;	//失敗
					}
				if ( kNumHenkanLevel > 4 ) {										//Level5解析開始	
					numCheck = NumToKnum( hyouki2 , hyouki3 , header , 1) ;		//与える変数は仮（動作確認済）
					strcpy( numberHyoki[*returnNum].hyoki , hyouki3 ) ;					//Level5解析文字列	
					(*returnNum)++ ;											//Level5終了	
					}

				}
			strcpy( numberHyoki[*returnNum].hyoki , hyouki2 ) ;		//Level2解析文字列
			(*returnNum)++ ;								//Level2終了
			}
		
		if ( levelFlag2 == 2 ) {		//入力が１２３・・・
			strcpy( hyouki2 , &inputBak[analyzeStrLength - length[ turn ] - length[0]] ) ;		//hyouki2を数字に
			
			if ( kNumHenkanLevel > 4 ) {										//Level5解析開始
				numCheck = NumToKnum( hyouki2 , hyouki3 , header , 1) ;		//与える変数は仮（動作確認済）
				strcpy( numberHyoki[*returnNum].hyoki , hyouki3 ) ;					//Level5解析文字列	
				(*returnNum)++ ;											//Level5終了
				}

			}

		hyouki[0] = '\0' ;		//初期化
		hyouki3[0] = '\0' ;		//初期化
		if ( kNumHenkanLevel > 2 && levelFlag == 0 && levelFlag2 != 0 ) {		//Level3解析開始
			strLength = strlen( hyouki2 ) ;								//Level2の結果の長さを得る
			if ( strLength == 0 ) return 0 ;								//保険部分
			for ( i = 0 ; i < strLength ; i += kLengthZenkaku ) {				//解析ループ
				dummy = NumsToNum(&hyouki2[i] ) ;				//数字 -> int
				if ( dummy == -1 ) return -1 ;							//ミスの場合失敗とする
				strncat( hyouki, header[dummy].numHyouki.kanjiNum , kLengthZenkaku) ;		//変換漢数字の付加	
#if 0	//半角の出力
				if ( kNumHenkanLevel > 3 ) {							//Level4解析開始
					strncat( hyouki3, (char*)(p+dummy) , 1 ) ;			//変換漢数字の付加	//
					}
#endif
				}
			strcpy( numberHyoki[*returnNum].hyoki , hyouki ) ;		//Level3解析文字列
			(*returnNum)++ ;								//Level3終了
			
#if 0	//半角の出力
			if ( kNumHenkanLevel > 3 ) {						//Level4解析開始
				strcpy( numberHyoki[*returnNum].hyoki , hyouki3 ) ;	//Level4解析文字列	
				(*returnNum)++ ;							//Level4終了
				}
#endif
			}
			
		SetNumsOut(*returnNum , returnNumBak , length[ turn ] + length[0] , lengthHankaku ) ;	//numberHyokiの設定

	return 0 ;			//成功
	
}

/***************************************************************
関数名	:	NumberHyoki::SetYomiNum
機能		:	数詞表記列のルールの設定
入力		:	data		数詞表記列のルール
出力		:	なし
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
void NumberHyoki::SetYomiNum(NumberHeader *data )

{
	short i , j ;
	short lengthNum ;		//kLengthNum / kLengthZenkaku
	jyosuCodeHeader	*header;
	unsigned char		*p,*p0,*tmpPtr;
	char 		yomiDigit[kHatsuSize+1][kYomiRuleSize];
	short numLength[] = { 2*kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku , 
					2*kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku ,  2*kLengthZenkaku , 3*kLengthZenkaku , 
					-1 , -1 ,  -1 , -1 , 2*kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku , 3*kLengthZenkaku , 
					3*kLengthZenkaku , 3*kLengthZenkaku , 3*kLengthZenkaku , 3*kLengthZenkaku , 2*kLengthZenkaku , 
					2*kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku , 3*kLengthZenkaku } ;
	short numKanji[] = { kLengthZenkaku , 3*kLengthZenkaku , 5*kLengthZenkaku , 8*kLengthZenkaku , 10*kLengthZenkaku , 
					11*kLengthZenkaku , 13*kLengthZenkaku , 14*kLengthZenkaku ,  15*kLengthZenkaku , 16*kLengthZenkaku  , 
					0 , 0 , 2*kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku , 3*kLengthZenkaku , 3*kLengthZenkaku , 
					4*kLengthZenkaku , 6*kLengthZenkaku , 7*kLengthZenkaku } ;
	short numCode[] = { 6*kLengthZenkaku , 8*kLengthZenkaku , 10*kLengthZenkaku , 12*kLengthZenkaku , 15*kLengthZenkaku , 
					18*kLengthZenkaku , 21*kLengthZenkaku , 24*kLengthZenkaku , 27*kLengthZenkaku , 29*kLengthZenkaku , 
					31*kLengthZenkaku , 33*kLengthZenkaku , 35*kLengthZenkaku } ;
	
	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0]+
			header->rule4Num[0];

	p = tmpPtr ;
	p0 = tmpPtr + header->rule5Num[0] +  header->rule6Num[0];
	
	lengthNum = kLengthNum / kLengthZenkaku ;
	
	InitYomiDigit("A" , yomiDigit ) ;
	
	for ( i = 0 ; i < lengthNum ; i++ ) {	//〇一二三四五六七八九
		strcpy( data[i].yomi , yomiDigit[i] );
		data[i].yomiLength = numLength[i] ;
		if ( i > 0 && i <= 3 ) {
			strncpy( data[i].numHyouki.kanjiNum , (char *)( p + numKanji[i] ) , kLengthZenkaku * 2 ) ;
			data[i].numHyouki.kanjiNum[kLengthZenkaku*2] = '\0' ;
			}
		else {
			strncpy( data[i].numHyouki.kanjiNum , (char *)( p + numKanji[i] ) , kLengthZenkaku ) ;
			data[i].numHyouki.kanjiNum[kLengthZenkaku] = '\0' ;	
			}
		}
		
	for ( i = 2 , j = 0 ; i < 6 ; i += 3 , j++ ) {	//二五
		strncpy( data[ j +lengthNum ].yomi , yomiDigit[i] , kLengthZenkaku );	
		data[ j + lengthNum ].yomi[kLengthZenkaku] = '\0' ;	
		data[ j + lengthNum ].yomiLength = kLengthZenkaku ;
		if ( i > 0 && i <= 3 ) {
			strncpy( data[ j + lengthNum ].numHyouki.kanjiNum , (char *)( p + numKanji[i] ) , kLengthZenkaku * 2 ) ;
			data[ j + lengthNum ].numHyouki.kanjiNum[kLengthZenkaku*2] = '\0' ;
			}
		else {
			strncpy( data[ j + lengthNum ].numHyouki.kanjiNum , (char *)( p + numKanji[i] ) , kLengthZenkaku ) ;
			data[ j + lengthNum ].numHyouki.kanjiNum[kLengthZenkaku] = '\0' ;	
			}
		}
		
		strncpy( data[ 2 +lengthNum ].yomi , yomiDigit[4] , kLengthZenkaku );	//四	
		data[ 2 + lengthNum ].yomi[kLengthZenkaku] = '\0' ;	
		data[ 2 + lengthNum ].yomiLength = kLengthZenkaku ;
		strncpy( data[ 2 + lengthNum ].numHyouki.kanjiNum , (char *)( p + numKanji[4] ) , kLengthZenkaku ) ;
		data[ 2 + lengthNum ].numHyouki.kanjiNum[kLengthZenkaku] = '\0' ;	
		
		strncpy( data[ 3 +lengthNum ].yomi , &yomiDigit[6][2] , kLengthZenkaku );	//九
		data[ 3 + lengthNum ].yomi[kLengthZenkaku] = '\0' ;	
		data[ 3 + lengthNum ].yomiLength = kLengthZenkaku ;	
		strncpy( data[ 3 + lengthNum ].numHyouki.kanjiNum , (char *)( p + numKanji[9] ) , kLengthZenkaku ) ;
		data[ 3 + lengthNum ].numHyouki.kanjiNum[kLengthZenkaku] = '\0' ;

	for ( i = lengthNum + 4 ; i < kLengthNumYomi ; i++ ) {	//数字の特殊な読み
		strncpy( data[i].yomi , (char *)( p0 + numCode[ i - lengthNum - 4 ] ) , numLength[i] );
		data[i].yomi[numLength[i]] = '\0' ;
		data[i].yomiLength = numLength[i] ;
		if ( i < kLengthNumYomi -  lengthNum ) {
			switch( i ) {
				case 14 : 	//いっ
					strncpy( data[i].numHyouki.kanjiNum , (char *)( p + numKanji[1] ) , kLengthZenkaku +kLengthZenkaku  ) ;
					data[i].numHyouki.kanjiNum[kLengthZenkaku+kLengthZenkaku] = '\0' ;
					break ;
				case 15 : 	//ろっ
					strncpy( data[i].numHyouki.kanjiNum , (char *)( p + numKanji[6] ) , kLengthZenkaku ) ;
					data[i].numHyouki.kanjiNum[kLengthZenkaku] = '\0' ;	
					break ;
				case 16 : 	//はっ
					strncpy( data[i].numHyouki.kanjiNum , (char *)( p + numKanji[8] ) , kLengthZenkaku ) ;
					data[i].numHyouki.kanjiNum[kLengthZenkaku] = '\0' ;	
					break ;
				}		
			}
		else {
			if ( i == 17 || i == 18 ) {				//「十」or「拾」
				strncpy( data[i].numHyouki.kanjiNum , 
					(char *)( p + numKanji[ i - ( kLengthNumYomi -  lengthNum ) + lengthNum] + kLengthKanji + kLengthNum + kLengthSpecialJosu ) ,
						kLengthZenkaku + kLengthZenkaku ) ;
				data[i].numHyouki.kanjiNum[ kLengthZenkaku + kLengthZenkaku ] = '\0' ;
				}
			else {
				strncpy( data[i].numHyouki.kanjiNum ,
					(char *)( p + numKanji[ i - ( kLengthNumYomi -  lengthNum ) + lengthNum] + kLengthKanji + kLengthNum + kLengthSpecialJosu ) , 
						kLengthZenkaku ) ;
				data[i].numHyouki.kanjiNum[kLengthZenkaku] = '\0' ;	
				}
			}
		}
		
	for ( i = kLengthNumYomi , j = 0 ; i < kLengthNumYomi + kSpecialJosuNum ; i++ , j += kLengthZenkaku ) {	//特殊な数字
		strncpy( data[i].yomi , yomiDigit[ i - ( kLengthNumYomi -  lengthNum ) + 2] , 2*kLengthZenkaku );
		data[i].yomi[2*kLengthZenkaku] = '\0' ;
		data[i].yomiLength = 2*kLengthZenkaku ;
		strncpy( data[i].numHyouki.kanjiNum , (char *)( p + kLengthKanji + kLengthNum + j ) , kLengthZenkaku ) ;
		data[i].numHyouki.kanjiNum[kLengthZenkaku] = '\0' ;
		}

}

/***************************************************************
関数名	:	NumberHyoki::NumToKnum
機能		:	全角の数字に対して漢数字を返す
入力		:	str			数字の文字列				
			out			入力に対する読み
			numHeader		数詞ルール
			oldNumFlag	旧の数字を表記を返すかどうか？		0	新漢数字　百二十三
														1	旧漢数字　壱百弐拾参
出力		:	0		成功
			それ以外	失敗
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
int NumberHyoki::NumToKnum( char *str, char *out , NumberHeader	*numHeader , short oldNumFlag )

{
	int		i, j, pos, len, keta, num2, num3;
	int numLengthTen ;		//これより上は特殊な数字
	char		buf[20] ;
	char yomiBak[strSize] ;	//ゴミ処理用
	jyosuCodeHeader	*header;
	unsigned char		*p0 , *tmpPtr;
	
	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0]+
			header->rule6Num[1];

	p0 = tmpPtr + header->rule7Num[0] +  header->rule8Num[0];
	numLengthTen = kLengthNumYomi - kLengthNum / kLengthZenkaku ;
	yomiBak[0] = '\0' ;
	
	keta = strlen(str) / kLengthZenkaku;		//  全角数字に対応した桁数の設定
	
	len = keta % 4;
	if( len == 0 )
		len = 4;				//  千までの桁を区切りにし，これを繰り返す
	pos = 0;
	num3 = 1 ;

	for(i = (keta - 1) / 4; i >= 0; i--)
	{
		strncpy(buf, str+pos, len*kLengthZenkaku);
		buf[ len * kLengthZenkaku ] = '\0' ;
		for(j = 0; j < len; j++)
		{
		
			num2 = NumsToNum(buf + j * kLengthZenkaku ) ;
			if ( num2 == -1 ) {	//数字変換ミス
				return -num3 ;		//それまでに変換できた個数
				}
			else {
				num3++ ;
				}		
			
			if( num2 || ( num2 == 0 && keta == 1 ))
			{
				if( ( oldNumFlag == 1 || num2 != 1 ) || (len - j) == 1 ) {			//  入力数字が１以外，または現在が一の位ならば
						if ( oldNumFlag == 1 && (num2 >= 1 && num2 <= 3 ) ) {														//
							strncat(yomiBak, &numHeader[num2].numHyouki.kanjiNum[kLengthZenkaku] , kLengthZenkaku);		//〇壱弐参四五六七八九
							}																							//
						else {																							//
							strncat(yomiBak, numHeader[num2].numHyouki.kanjiNum , kLengthZenkaku);		//〇一二三四五六七八九			//
							}																							//
						}
				switch( len - j )								//　その他の入力数字の場合
				{
					case 4: strcat(yomiBak, numHeader[numLengthTen+5].numHyouki.kanjiNum );	//　千
							break;
					case 3: strcat(yomiBak, numHeader[numLengthTen+2].numHyouki.kanjiNum );	//　百
							break;
					case 2:
						if ( oldNumFlag == 1 ) {
							strncat(yomiBak, &numHeader[numLengthTen].numHyouki.kanjiNum[kLengthZenkaku] , kLengthZenkaku);		//　拾
							}																		//
						else {																		//
							strncat(yomiBak, numHeader[numLengthTen].numHyouki.kanjiNum , kLengthZenkaku);		//　十	
							}																		//
						    	break;
					default:break;
					}
				}
			}
			if( strncmp(buf, (char*)p0, len*kLengthZenkaku) )
				switch( i )
				{
					case 3: strcat(yomiBak, numHeader[numLengthTen+9].numHyouki.kanjiNum );	//兆
							break;
					case 2: strcat(yomiBak, numHeader[numLengthTen+8].numHyouki.kanjiNum );	//億
							break;
					case 1: strcat(yomiBak, numHeader[numLengthTen+7].numHyouki.kanjiNum );	//万
							break;
					default:break;
				}
			pos += len * kLengthZenkaku;
			len = 4;
	}

	strcpy( out , yomiBak ) ;
	
	return 0 ;
	
}

/***************************************************************
関数名	:	NumberHyoki::NumsToNum
機能		:	全角の数字をint型に
入力		:	check	検査文字（全角）
出力		:	入力が０から９ならばその数を返す
			「何」ならば１２を返す
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
int NumberHyoki::NumsToNum(char *check )
{
	int				i , j ;
	jyosuCodeHeader	*header;
	unsigned char		*p,*tmpPtr;
	
	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0]+
			header->rule4Num[0];

	p = tmpPtr +kLengthKanji ;//．〇零一壱二弐三参四五六七八九の長さ
	
	for ( i = 0 ; i < kLengthNum + kLengthSpecialJosu ; i += kLengthZenkaku ) {
		if ( !strncmp(&check[0],(char*)(p+i) , kLengthZenkaku) ){			//見つかった		
			j =(int)( i / kLengthZenkaku );
			if ( j > 9 ) j += kSpecialJosuNum ;
			return j;
			}
		}
		
	return -1 ;
	
}

/***************************************************************
関数名	:	NumberHyoki::GetPointKnum
機能		:	KnumtoNum用 小数点以下の漢字を全角の数字に直す
入力		:	str			全角数字列
			point		漢数字列
出力		:	なし
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
void NumberHyoki::GetPointKnum(char *str , char *point )

{
	jyosuCodeHeader	*header;
	unsigned char		*p,*tmpPtr;
	char out2[kMaxHyokiSize] ;			//入力文の小数点以下出力用変数
	
	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0]+
			header->rule5Num[1];

	p = tmpPtr ;
	
	out2[0] = '\0' ;
	
	strncat( str , (char*)p , kLengthZenkaku ) ;				//小数点を付加
	KnumtoNum(point , out2 ) ;		//小数点以下を全角の数字に
	strcat( str , out2 ) ;				//組み合わせる
	
}

/***************************************************************
関数名	:	NumberHyoki::KnumtoNum
機能		:	漢数字（小数点を含む）を全角の数字に変換する
入力		:	input		漢数字部
			out			入力に対する全角の数字
出力		:	区切った位置
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
int NumberHyoki::KnumtoNum(char *input , char *out )	

{
	int numData[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,3,4,4,8,12 };	//数字部分の係数
	char point[kMaxHyokiSize] ;			//入力文の小数点以下保存用変数
	int  i , j , k , l ;					//作業用変数
	int lengthNumber , lengthInput ;		//文字列の長さ
	int flag , flag2 , flag3, flag4;		//フラグ用変数						
	int backNum ;					//前の数字の保存用変数
	int nextNum ;					//NextCheck用変数
	int cutIchi ;					//読みが区切れる位置
	int length ;					//kLengthKanji + kLengthNum  kLengthSpecialJosu
	jyosuCodeHeader	*header;
	unsigned char		*p,*p0,*tmpPtr;
	char numDigit[ ( kLengthKanji + kLengthNum + kLengthSpecialJosu ) / kLengthZenkaku  + 1 ][ kLengthZenkaku + 1 ] ;
	
	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0];

	p = tmpPtr + header->rule4Num[0] ;
	p0 = tmpPtr + header->rule8Num[1] ;		//０の文字列
	InitNumDigit (numDigit ) ;
	length = kLengthKanji + kLengthNum + kLengthSpecialJosu;
	
	lengthNumber = header->rule5Num[0] ;		//数字部分の長さ
	lengthInput = strlen( input ) ;			//入力部分の長さ
											////////////////////////////////////////////
	out[0] = '\0' ;			//初期設定				// flag 	0 :  デフォルト
	point[0] = '\0' ;		//初期設定					// flag	1 :  前の「十\拾百千万萬億兆」を記憶している
	k = 0 ;			//デフォルト				// flag 	2 :  さらに「〇零一壱二弐三参四五六七八九」がある
	l = 0 ;			//デフォルト				// flag2	0 : 「十\拾百千万萬億兆」が続いていない
	backNum = 0 ;		//デフォルト				// flag2	1 : 「十\拾百千万萬億兆」が続いている
	nextNum = 0 ;		//デフォルト				// flag3	0 : 「十\拾百千万萬億兆」がない
	cutIchi = 0 ; 								// flag3	1 : 「十\拾百千万萬億兆」が一つでもある
	
	FlagClear( &flag , &flag2 , &flag3 , &flag4 );

	for( i = 0 ; i <= lengthInput ; i += kLengthZenkaku ) {		//入力部検索
		if( input[ i ] == (char)p[ kKonmaIchi ] && input[ i + 1] ==  (char)p[ kKonmaIchi + 1] ) {
			out[0] = '\0' ;
			FlagClear( &flag , &flag2 , &flag3 , &flag4 );
			i += kLengthZenkaku ;
			cutIchi = i ;
			}	
		for( j = 0 ; j < lengthNumber ; j += kLengthZenkaku ) {		//数字かどうか調べる
			if ( !strncmp(&input[i],(char*)(p+j) , kLengthZenkaku) ){			//見つかった		
				if ( j == 0 ) {							//小数点である
					if ( i != 0 ) {		//先頭以外
						strcat( point , &input[ i + kLengthZenkaku] ) ;			//小数点以下を保存
						i = lengthInput ;						//ループを抜ける準備
						break ;							//ループを抜ける
						}
					else {
						cutIchi = i + kLengthZenkaku ;
						break ;
						}
					}
				if ( j < length ) {			//「〇零一壱二弐三参四五六七八九０１２３４５６７８９」の場合
					if ( flag4 == 1 && flag3 == 1) {	//数字が続くのに「十\拾百千万萬億兆」が一つでもある場合
						out[0] = '\0' ;
						cutIchi = i ;
						//特殊操作（　３万４５６７　と　三万四千五六十七　）	の読みを可能にする
						//k　は	前の「十拾百千万萬億兆」の係数
						//「万萬億兆」以上なら区切りの位置を変える				
						if ( k > kDataThousand && j > kLengthKanji - 1) {	
							cutIchi -= kLengthZenkaku ;
							i -= kLengthZenkaku ;
							}	
						FlagClear( &flag , &flag2 , &flag3 , &flag4 );
						i -= kLengthZenkaku ;
						break ;
						}
					flag2 = 0 ;
					flag4 = 1 ;
					if ( flag == 1 ) {		
						backNum = j ;		//前の数字を保存
						flag = 2 ;
						}
					else {				//それ以外
						strcat( out , numDigit[ j / kLengthZenkaku ] ) ;		//数字を付加
						}
					}
				else {				//「十\拾百千万萬億兆」の場合
					flag4 = 0 ;
					if ( flag2 == 1&& j < length + kLengthBKanji - 1  ) {	//続けて「十\拾百千」が見つかった
						if ( k == 3 && ( j == length || j == length + kLengthZenkaku  ) ) {	//「千十\」「千拾」の組み合わせ
							strcat( out , numDigit[1] ) ;	//０の付加
							strcat( out , numDigit[3] ) ;	//１の付加
							}
						else if ( k == numData[ j / kLengthZenkaku ] ) {	//同じのが続いている
							strcpy( out , numDigit[3] ) ;	//１の付加
							cutIchi = i ;
							}
						else  {		//順序が正しくない
							strcat( out , numDigit[3] ) ;	//１の付加
							 if ( k < numData[ j / kLengthZenkaku ] && flag3 == 1 ) {	//連続して順序が正しくない
								out[0] = '\0' ;
								cutIchi = i ;
								FlagClear( &flag , &flag2 , &flag3 , &flag4 );
								i -= kLengthZenkaku ;
								break ;
								}
							}
						}		
					nextNum = 0 ;			//初期化
					if ( flag == 2 ) {
							l =  ( k - numData[ j / kLengthZenkaku ] - 1) * kLengthZenkaku ;		//数字の係数比較
							if ( l < 0 ) {			//数字の順序が正しくない
								if ( j > length + kLengthBKanji - 1 ) {		//「万」以上の場合
									strncat( out , (char*)p0 , ( k - 1 ) * kLengthZenkaku ) ;		//０を付加
									//「万」以下の順序をcheck
									nextNum = NextCheck(input + i + kLengthZenkaku , 
										numData[ j / kLengthZenkaku ] ) ;	
									if ( nextNum < 0 ) {		//「万」以上の順序が正しくない
										out[0] = '\0' ;	//初期化
										cutIchi = i + kLengthZenkaku ;
										}
									else {				//「万」以上の順序が正しい
										//付加する０の個数を計算
										k = numData[ j / kLengthZenkaku ] - nextNum - 1;
										strcat( out , numDigit[ backNum / kLengthZenkaku ]  ) ;
										strncat( out , (char*)p0 , k * kLengthZenkaku ) ;	//０を付加
										}
									flag = 0 ;
									k = numData[ j / kLengthZenkaku ] ;		//数字の係数を保存
									flag2 = 1 ;
									flag3 = 1 ;
									break ;			//ループを抜ける
									}
								else {			//「千」以下の場合
									out[0] = '\0' ;				//初期化
									strcat( out , numDigit[ backNum / kLengthZenkaku ]  );	//数字を付加
									cutIchi = i - kLengthZenkaku ;
									}
								}
							else {						//数字の順序が正しい
								strncat( out , (char*)p0 , l ) ;		//０を付加	
								strcat( out , numDigit[ backNum / kLengthZenkaku ]  ) ;	//数字を付加
								}
							k = numData[ j / kLengthZenkaku ] ;			//数字の係数を保存
							flag = 1 ;
						}
					else {		//それ以外
						if ( j > length + kLengthBKanji - 1 ) {			//「万」以上の場合
								if ( flag2 != 0 ) {	//「十\拾百千万萬億兆」が続いている
									if ( flag == 0 ) {
										out[0] = '\0' ;	//初期化
										k = 0 ;		//初期化
										cutIchi = lengthInput ;	
										i = lengthInput ;
										break ;
										}
									else {
										strncat( out , (char*)p0 , k * kLengthZenkaku ) ;		//０を付加
										}
									}
								//「万」以下の順序をcheck
								nextNum = NextCheck(input + i + kLengthZenkaku , 
												numData[ j / kLengthZenkaku ]) ;
								if ( nextNum < 0 ) {		//「万」以上の順序が正しくない
									out[0] = '\0' ;	//初期化
									k = 0 ;		//初期化
									cutIchi = i + kLengthZenkaku ;
									}
								else {				//「万」以下の順序が正しい
									k = numData[ j / kLengthZenkaku ] - nextNum - 1;	//０の個数を計算
									strncat( out , (char*)p0 , k * kLengthZenkaku ) ;	//０を付加
									k = numData[ j / kLengthZenkaku ];			//数字の係数を保存
									}	
								flag = 0 ;
								}
						else {					//「千」以下の場合
							k = numData[ j / kLengthZenkaku ] ;	//数字の係数を保存
							flag = 1 ;
							}
						}
					flag2 = 1 ;
					flag3 = 1 ;
					}
			}
		}
	}
	
	if ( flag2 == 0 && flag3 == 1 && flag != 0 ) {
		strncat ( out , (char*)p0 , ( k - numData[backNum / kLengthZenkaku ] - 1 ) * kLengthZenkaku ) ;	//０を付加
		strcat( out , numDigit[ backNum/ kLengthZenkaku ] ) ;		//数字を付加
			}
			
	if ( i == lengthInput + kLengthZenkaku  && flag2 == 1 ) {
		if ( flag == 0 && out[0] != '\0' ) {
			strcat( out , numDigit[1] ) ;	//０の付加
			}
		else {
			strncat ( out , (char*)p0 , k* kLengthZenkaku ) ;		//０を付加
			}
		}
		
	if ( j == 0 ) {						//小数点があった
		GetPointKnum(out , point ) ;		//小数点以下の漢字を全角の数字に直す
		}
	
	return cutIchi ;

}

/***************************************************************
関数名	:	NumberHyoki::CheckPointKonma
機能		:	２byteの”．”や”，”があるかどうか返す
入力		:	length				変換文字列の長さ
			input				入力文字列
出力		:	1	”．”や”，”がある
			0	”．”や”，”がない
			-1	エラー
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
int NumberHyoki::CheckPointKonma(char *input ) 

{
	jyosuCodeHeader	*header;
	unsigned char		*p,*tmpPtr;

	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0];


	p = 	tmpPtr + header->rule4Num[0];

	if ( !strncmp(input,(char*)(p+kPointIchi),kLengthZenkaku) ){
		return 1 ;
		}

	if ( !strncmp(input,(char*)(p+kKonmaIchi),kLengthZenkaku) ){
		return 1 ;
		}

	return 0 ;
	
}

/***************************************************************
関数名	:	NumberHyoki::SetNumsOut
機能		:	numberHyokiの設定
入力		:	returnNum						返すnumberHyokiの個数
			returnNumBak					桁数が一つ少ない時点での返すnumberHyokiの個数
			length						数詞が変換された長さ
			lengthHankaku					変換された半角の長さ
出力		:	なし
作成日	:	98.1.23
***************************************************************/
void NumberHyoki::SetNumsOut(int returnNum , int returnNumBak , int length , int lengthHankaku) 

{
	int i ;
	
	for ( i = returnNumBak ; i < returnNum ; i++ ) {
		if ( lengthHankaku > 0 ) {
			numberHyoki[i].hyokiLength = length / kLengthZenkaku;		//数詞の長さ
			}
		else {
			numberHyoki[i].hyokiLength = length ;		//数詞の長さ
		}
		numberHyoki[i].hinshiFlag = 0 ;			//数詞のみである
		}
		
}

/***************************************************************
関数名	:	NumberHyoki::CheckHankaku
機能		:	半角check
入力		:	analyzeStr	解析文字列
			offset		checkする位置
出力		:	1		１Byte
			2		2Byte
			3		3Byte
			-1		それ以外
作成日	:	98.1.23
***************************************************************/
int NumberHyoki::CheckHankaku( char *analyzeStr , short  offset )

{
	unsigned char *codeCheck ;
	
	codeCheck = (unsigned char*)analyzeStr ;
	
	if  ( offset < 0 ) return -1 ;

	if ( codeCheck[0] <= 0x7F ) return 1 ;

	if ( codeCheck[0] <= 0xDF  && codeCheck[0] >= 0xC2) return 2 ;

	if ( codeCheck[0] <= 0xEF  && codeCheck[0] >= 0xE0) return 3 ;

	return -1 ;
}

/***************************************************************
関数名	:	NumberHyoki::InitNumDigit
機能		:	numDigitを設定する
入力		:	numDigit		KnumtoNum用の数字の読み
出力		:	なし
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
void NumberHyoki::InitNumDigit(char numDigit[ ( kLengthKanji + kLengthNum + kLengthSpecialJosu ) / kLengthZenkaku + 1 ][ kLengthZenkaku + 1 ])

{
	int  i,j;
	jyosuCodeHeader	*header;
	unsigned char		*p,*tmpPtr;
	int numData[] = { 19*kLengthZenkaku , 0 , 0 , kLengthZenkaku , kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku , 2*kLengthZenkaku ,  
				3*kLengthZenkaku , 3*kLengthZenkaku , 4*kLengthZenkaku , 5*kLengthZenkaku , 5*kLengthZenkaku , 6*kLengthZenkaku , 
				7*kLengthZenkaku , 8*kLengthZenkaku , 9*kLengthZenkaku , 0 , kLengthZenkaku , 2*kLengthZenkaku , 3*kLengthZenkaku ,
				4*kLengthZenkaku , 5*kLengthZenkaku , 6*kLengthZenkaku , 7*kLengthZenkaku , 8*kLengthZenkaku , 9*kLengthZenkaku , 
				10*kLengthZenkaku , 11*kLengthZenkaku } ;

	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0]+
			header->rule4Num[0];

	p = tmpPtr + kLengthKanji ;	//．〇零一壱二弐三参四五六七八九

	for ( i = 0 ; i < ( kLengthKanji + kLengthNum + kLengthSpecialJosu ) / kLengthZenkaku ; i++ ) {	//データの分割
		for ( j = 0 ; j < kLengthZenkaku ; j++ ) {
			numDigit[i][j] =  p[ numData[i] + j ] ;
			}
		numDigit[i][kLengthZenkaku] = '\0' ;
		}

}

/***************************************************************
関数名	:	NumberHyoki::InitYomiData
機能		:	読みのルールの初期設定（基本）
入力		:	code			助数詞ルールのコード
			yomi			数詞の変化ルール
出力		:	0		見つかった
			-1		エラー
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
int NumberHyoki::InitYomiDigit(char *code , char yomi[kHatsuSize+1][kYomiRuleSize] ) 

{
	int				i , j , k ;
	jyosuCodeHeader	*header;
	unsigned char		*p,*p0,*tmpPtr;
	
	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader);

	tmpPtr += header->rule1Num[1]*header->rule1Num[0];
	p = tmpPtr + kYomiSize * (int)( code[0]  - 'A' );
	p0 = tmpPtr + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0]+header->rule5Num[1];
	p0 += kLengthJosuElseAdd ;

	for ( i = 0 , j = 0 , k = 0 ; i < header->rule1Num[1] ; i++ ) {	//データの分割
		while ( ( yomi[i][j++] = p[k++] ) != ' ' ) ;
		yomi[i][--j]  = '\0' ;
		j = 0 ;
		}
		
	if ( i == 0 ) {
		return -1 ;
		}

	for ( k = 0 ; k < kSpecialJosuNum ; k++ , p0 += 2*kLengthZenkaku) {
		strncpy( yomi[ i + k ] , ( char *)p0 , 2*kLengthZenkaku ) ;
		yomi[ i + k ][2*kLengthZenkaku] = '\0' ;
		}

	return 0 ;
	
}

/***************************************************************
関数名	:	NumberHyoki::ChangeNumToNum
機能		:	半角から全角へのフィルタ（数字のみ）
入力		:	str			入力文字列
			length		入力文字列の長さ
			endLength		検索する半角以降の長さ
			flag			フラグ		0		通常の変換	
									1		コンマ（小数点）のみ変換
			errorPoint	フラグ		1		コンマ（小数点）にエラーを発見
出力		:	変換されたバイト数	
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
int NumberHyoki::ChangeNumToNum(char *str , int length , int endLength, short flag , short *errorPoint ) 
{
	short i , j , k , l ;
	short checkKonma ;
	short num ;		//	kLengthNum / kLengthZenkaku
	short ret ;
	short bakPoint ;
	jyosuCodeHeader	*header;
	unsigned char		*p,*tmpPtr;
	short numHankaku[ kLengthHankakuNum + 1 ] ;
	char bakStr[ strSize ] ;
	//konmaFlag	コンマ（小数点）が見つかったときその位置を示す。
	short konmaFlag = 0 ;

	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0]+
			header->rule7Num[1];

	p = tmpPtr ;
	ret = 0 ;	
	k = 0 ;
	l = 0 ;
	bakPoint = length - endLength ;
	checkKonma = 0 ;
	num = kLengthNum / kLengthZenkaku ;
	
	if ( length == 0 || bakPoint < 0 )  return 0 ;
	
	for ( i = length - 1 - endLength ; i >= 0 ; i -- ) {
	
	if ( CheckHankaku( str , i ) != 1 )  {		//半角check
		if ( k > 0 && bakPoint - 1 == i ) {
			k-- ;
			}
		break ;
		}
		
	if ( k == kLengthHankakuNum ) {			//変換オーバー
		break ;
		}

		for ( j = 0 ; j <  header->rule8Num[2] ; j ++ ) {
			if ( str[i] == (char)p[j] ) {	//見つかった
				if ( j >= num ) {		//コンマ（小数点）
					//コンマ（小数点）が２つ続く or　2byteコンマ（小数点）+ 1byteコンマ（小数点） or　1byteコンマ（小数点）+ 2byteコンマ（小数点）
					if ( ( bakPoint == i + 1 && konmaFlag > 0 ) ||
						( i >= kLengthZenkaku && CheckPointKonma( &str[i-kLengthZenkaku] ) == 1 ) ||
						( flag == 1 && CheckPointKonma(&str[i+1] ) == 1 )
						) {
						*(errorPoint) = 1 ;
						j = header->rule8Num[2] ;
						break ;
						}
					if ( flag == 0 ){
						if  ( i == 0 || ( ( j == num && bakPoint != length - endLength ) ||  ( j == num + 1  && bakPoint - i != 4 ) ) ) {
							j = header->rule8Num[2] ;
							break ;
							}
						else  {
							konmaFlag = i ;
							}
						}
					else {
						numHankaku[k] = j ;
						k++ ;
						j = header->rule8Num[2] +1;
						checkKonma = 1 ;
						break ;
						}
					bakPoint = i ;
					}
				numHankaku[k] = j ;
				k++ ;
				break ;
				}
			}
		if ( j == header->rule8Num[2] ) {		//見つからない
			if ( i == length - 1 ) {		//半角じゃない
				return 0 ;
				}
			//コンマ（小数点）が２つ続いた（保険）
			if ( konmaFlag == i+1 ) {
				k -- ;
				}
			break ;
			}
		}
	
	if ( flag == 1 && checkKonma == 0 ) return -1 ;
	
	//コンマ（小数点）が２つ続いた（保険）
	if ( flag == 0 && k > 0 && numHankaku[k-1] >= num ) k-- ;

	if ( k > 0 ) {		//半角が存在する
		if ( k + length + endLength > strSize )  {		//変換オーバー
			return 0 ;
			}
		l = k ;
		strcpy(bakStr , &str[length-endLength] ) ;
		str[length-l-endLength] = '\0' ;
		
		for ( j = k - 1 ; j >= 0 ; j-- ) {		//全角への変換
			strncat( str , (char *)( p + numHankaku[j] * kLengthZenkaku + header->rule8Num[2] ), kLengthZenkaku ) ;
			l -= kLengthZenkaku ;
			str[length-l-endLength] = '\0' ;
			}
		ret = k ;
		strcat(str, bakStr);
		}

	return ret ;					
}

/***************************************************************
関数名	:	NumberHyoki::FlagClear
機能		:	KnumtoNum用 フラグの初期化
入力		:	flag , flag2 , flag3 , flag4		読み方フラグ
出力		:	なし
作成日	:	98.1.23
***************************************************************/
void NumberHyoki::FlagClear( int *flag , int *flag2 , int *flag3 , int *flag4 )
{
	*flag = 0		;
	*flag2 = 1 	;
	*flag3 = 0	;
	*flag4 = 0	;
	
}

/***************************************************************
関数名	:	NumberHyoki::NextCheck	
機能		:	「万」以上の順序をcheckし、KnumtoNumに必要な値を返す
入力		:	kanjiNumber			漢数字部
			upNumData				直前の「万萬億兆」の係数
出力		:	0				入力部分がNULLである
			-1				「万」以上の順序が正しくない
			back_num			見つかった「十\拾百千」の係数の内、一番大きいもの				
			num_dat[]			「万」以上の係数
作成日	:	98.1.23
修正日	:	98.2.16
***************************************************************/
int NumberHyoki::NextCheck(char *kanjiNumber , int upNumData)
{
	int numData[] = { 1,1,2,3,4,4,8,12,0,0 };	//数字部分の係数
	int  i , j , k  ;						//作業用変数
	int lenKanjiNum ;					//文字列の長さ
	int flag;							//フラグ用変数	
	int backNum ;						//係数保存用変数
	int konmaIchi ;						//kKonmaIchi - kLengthKanji - kLengthNum
	jyosuCodeHeader	*header;
	unsigned char		*p,*tmpPtr;

	header = &fHeader;
	tmpPtr = rule + sizeof(jyosuCodeHeader) + 
		header->rule1Num[1]*header->rule1Num[0] + header->rule2Num[1]*header->rule2Num[0]+header->rule3Num[1]*header->rule3Num[0]+
			header->rule4Num[0];

	p = tmpPtr + kLengthKanji + kLengthNum + kLengthSpecialJosu; 	// ．〇零一壱二弐・・・・の長さ

	lenKanjiNum = strlen( kanjiNumber ) ;		//入力部分の長さ	//	flag 0 : 「万」以上が見つかっていない
														//	flag 1 : 「万」以上が見つかっている
	
	flag = 0 ;			//デフォルト								
	k = 0 ;			//デフォルト
	backNum = 0 ;		//デフォルト
	konmaIchi = kKonmaIchi - kLengthKanji - kLengthNum ;
	
	if ( lenKanjiNum == 0 || kanjiNumber[0] == '\0' ) {	//入力部分がNULL
		return 0 ;						//０を返す
		}
		
	for( i = 0 ; i < lenKanjiNum ; i += kLengthZenkaku ) {		//入力部検索	
		for( j = 0 ; j < kLengthNum ; j += kLengthZenkaku ) {	//数字かどうか調べる
			if ( !strncmp(&kanjiNumber[i],(char*)(p+j) , kLengthZenkaku) ){			//見つかった		
				if ( j == konmaIchi || j == konmaIchi + kLengthZenkaku ) {			//小数点が見つかった
					if ( k == 0 ) {					//小数点のみである			
						return( backNum ) ;		//見つかった「十\拾百千」の係数の内、一番大きいものを返す
						}
					else {					//それ以外
						return( numData[ k / kLengthZenkaku ] + backNum ) ;	//「万」以上の係数とbackNumを返す
						}
					}
				if ( j > kLengthBKanji - 1   && flag == 0 ) {	//初めて「万」以上が見つかった
					k = j ;			//kに保存
					flag = 1 ;			//flagを１に
					}
				else if ( numData[ j / kLengthZenkaku ] > backNum && flag != 1 ) {	//「十\拾百千」が見つかった
					backNum = numData[ j / kLengthZenkaku ] ;					//その係数を保存
					}
				if ( flag == 1 && upNumData <= numData[ j / kLengthZenkaku ]  ) {	//「万」以上がまた見つかった
					k = -1 ;			//kを-1に
					}
				}
			}
		}
	if ( k < 0 ) {			//kが負の場合
		return -1 ;		//-1を返す
		}
	if ( flag == 0 ) {		//「万」以上が見つかっていない
		return( backNum ) ;	//見つかった「十\拾百千」の係数の内、一番大きいものを返す
		}
	else	{				//「万」以上が見つかった
		return( numData[ k / kLengthZenkaku ] + backNum ) ;	//「万」以上の係数とbackNumを返す
		}
		
}

/***************************************************************
関数名	:	NumberHyoki::GetNumLength	
機能		:	数詞の長さを得る
入力		:	at					アクセステーブル
			analyzeStrLength		解析文字列
			times				数詞の個数（桁数）
			length				おのおのの数詞の長さ
			cutOverFlowLength		解析に関係ない上部のカットした長さ
出力		:	見つかった数詞の長さ
作成日	:	98.1.23
***************************************************************/
int NumberHyoki::GetNumLength(AccessTable& at , short analyzeStrLength , short *times, int length[], int cutOverFlowLength )
{
	short	lengthOut ; 		//連続した数詞の長さ
	short 	numLength ;		//見つかった数詞の長さ
	short 	numBak ;
	int i ;
	
	lengthOut = 0 ;
	numLength = 0 ;
	numBak = 0 ;
	
	do {
		numLength = CheckSuushi( at , analyzeStrLength - lengthOut - kLengthZenkaku , 0 , cutOverFlowLength) ;		//数詞を見つける
		if ( numLength == 0 ) {		//見つからない
			for ( i = numBak ; i <= analyzeStrLength - lengthOut - kLengthZenkaku+ numBak; i += kLengthZenkaku ) {
				numLength = CheckSuushi( at , analyzeStrLength - lengthOut - kLengthZenkaku + numBak , i , cutOverFlowLength) ;		//数詞を見つける
				if ( numLength != 0 ) {
					(*times)-- ;				//見つかった数詞の個数--
					lengthOut -= numBak ;
					break ;
					}
				}
			}
		numBak = numLength ;
		lengthOut += numLength ;		//見つかった数詞を加える
		length[*times] = lengthOut ;	//見つかった数詞を保存
		(*times)++ ;				//見つかった数詞の個数++
		if ( *times > NumHyokiMax - 1 ) {	//個数が配列の最大値をオーバー
			*times = 0 ;				//個数を0にする
			return lengthOut ;			//それまでの長さを返す
			}
		if ( analyzeStrLength - lengthOut == 0 ) break ;		//解析する文字列がない
	} while ( numLength != 0 ) ;
	
	if ( numLength == 0 ) (*times)-- ;		//数詞が見つからずにループを抜けた場合

	return lengthOut ;
	
}

/***************************************************************
関数名	:	NumberHyoki::CheckSuushi	
機能		:	数詞を探す
入力		:	at					アクセステーブル
			loop					終了位置
			start				開始位置
			cutOverFlowLength		解析に関係ない上部のカットした長さ	
出力		:	見つかった数詞の長さ
作成日	:	98.1.23
修正日	:	98.1.26
***************************************************************/
int NumberHyoki::CheckSuushi( AccessTable& at , int loop , int start , int cutOverFlowLength )

{	
	int length ;
	int i ;
	
	length = 0 ;
	
	for ( i = start ; i <= loop ; i += kLengthZenkaku ) {
		if(at.CheckSuusi(cutOverFlowLength + loop - i,i + kLengthZenkaku) == true){
			length = i + kLengthZenkaku;
			break;
		}
	}
	return length;
}
